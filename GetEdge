void GetEdge(HWND hwnd, BITMAP bmp, EDGE *path, BYTE *pDots){
	int x,y,mx,my,dx,dy,ux,uy,d,t,dt,status;
	BYTE *p,*q,*r;
	char buf[100];
	DIRECTION directions[8] = { { 0, 1 }, {1,1}, { 1, 0 }, { 1, -1 }, { 0, -1 },  { -1, -1 }, { -1, 0 },{ -1, 1 } };
	POINT pt[10000];

	q=pDots;
	for(y=0;y<bmp.bmHeight;y++){
		p=(BYTE*)bmp.bmBits+y*bmp.bmWidthBytes;
		for(x=0;x<bmp.bmWidth;x++,q++){
			if(p[4*x]>0x80 && p[4*x+1]>0x80 && p[4*x+2]>0x80){//background
				*q=0;				
				p[4*x]=0x00; p[4*x+1]=0x00 ; p[4*x+2]=0x00;
			}else{ //image
				*q=1;
				p[4*x]=0x00; p[4*x+1]=0x00 ; p[4*x+2]=0xF0;
			}
		}
	}
	//find the first dot of the image
	p=pDots;
	for(y=0;y<bmp.bmHeight;y++){
		for(x=0;x<bmp.bmWidth;x++,p++){
			if(*p==1){
				path->DotNum = 0;
				path->start.x = x;
				path->start.y = y;
				y = bmp.bmHeight;
				x = bmp.bmWidth;				
			}
		}
	} 
	//Trace the edge
	path->DotNum=0;
	mx = x = path->start.x;
	my = y = path->start.y;
	r = p = pDots + y*bmp.bmWidth + x;
	dt=0;status=-1;
	do{
		for(t=0;t<8;t++){
			d=(dt+t)%8;
			dx = x + directions[d].x;
			dy = y + directions[d].y;
			q = pDots + dy * bmp.bmWidth + dx;

			if(*q != *r && r != p ){
				if(*q==1 && *r==0){ux=dx,uy=dy;}
				if(*q==0 && *r==1){ux=mx,uy=my;}
				status = AddDot(path,pt,ux,uy);
				switch(status){
					case 0:
						return;
					case -1:
						path->directions[path->DotNum]=d; 
						pt[path->DotNum].x = path->current.x = x = ux; 
						pt[path->DotNum].y = path->current.y = y = uy;
						path->DotNum++;
						break;
					case 1:
						x=ux;y=uy;
						break;
				}
				dt=d+5;t=7;
			}else{
				r=q;mx=dx;my=dy;
			}
		}
		*((BYTE*)bmp.bmBits+y*bmp.bmWidthBytes+x*4+1)=0xFF;
	}while(status!=0);	
}
int AddDot(EDGE* path, POINT *pt,int x,int y){
	int i;
	if(path->start.x == x && path->start.y == y)return 0;
	for(i=0;i<path->DotNum;i++){
		if(pt[i].x==x && pt[i].y==y)return 1;
	}
	return -1;
}
//----------------------------------------------------------------------------------------------------------
/*
A complete code for Digital Image process with a demo for bitmap on windows API(32) including Grey, Histogram, Binary, Domain, and Edge operations.
*/
#include <windows.h>
#include <stdio.h>

VOID BinaryBmp(BITMAP *pBmp, BYTE threshold);
//将二值图的连通区域 标记 为不同颜色
VOID GetDomain( BITMAP *pBmp, BYTE **Image, int **map, int *DomainsCount, POINT **DomainPoints,int **mark,int *labelcount);
VOID GetEdge(BITMAP *pBmp,BYTE **Image);
VOID GetHistogram(BITMAP *pBmp, int *histogram, int histogramSize, int *avHistogram, int *maxHistogram);

VOID GreyBmp(BITMAP *pBmp);

VOID ShowBmpInfo(HWND hwnd, BITMAP *pBmp);
VOID ShowImage(HDC hdc, BITMAP bitmap, int *pMap);

LRESULT CALLBACK WndProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);
int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, PSTR szCmdLine, int iCmdShow){
	static TCHAR szAppName[] = TEXT("HelloWin");
	HWND hwnd;
	MSG msg;
	WNDCLASS wndclass;
	wndclass.style = CS_HREDRAW | CS_VREDRAW;
	wndclass.lpfnWndProc = WndProc;
	wndclass.cbClsExtra = 0;
	wndclass.cbWndExtra = 0;
	wndclass.hInstance = hInstance;
	wndclass.hIcon = LoadIcon(NULL,IDI_APPLICATION);
	wndclass.hCursor = LoadCursor(NULL,IDC_ARROW);
	wndclass.hbrBackground = (HBRUSH)GetStockObject(WHITE_BRUSH);
	wndclass.lpszMenuName = NULL;
	wndclass.lpszClassName = szAppName;
	if(!RegisterClass(&wndclass)){
		MessageBox(NULL,TEXT("This program requires Windows NT!"), szAppName, MB_ICONERROR);
		return 0;
	}
	hwnd = CreateWindow(szAppName,TEXT("The Hello Program"),WS_OVERLAPPEDWINDOW,CW_USEDEFAULT,CW_USEDEFAULT,CW_USEDEFAULT,CW_USEDEFAULT,NULL,NULL,hInstance,NULL);
	ShowWindow(hwnd,iCmdShow);
	UpdateWindow(hwnd);
	while(GetMessage(&msg,NULL,0,0)){
		TranslateMessage(&msg);
		DispatchMessage(&msg);
	}
	return msg.wParam;
}
LRESULT CALLBACK WndProc(HWND hwnd, UINT message,WPARAM wParam,LPARAM lParam){
	HANDLE hInstance;
	HDC hdc,hdcMem;
	PAINTSTRUCT ps;
	RECT rect;
	HFONT hFont;
	char buf[100];
	static HBITMAP hBitmap;
	static BITMAP bitmap;
	static LPCSTR filename = "gear.bmp";
	static BYTE *pOrigin,*p,*pImage;
	static int *pMap,*histogram,histogramSize=256,avHistogram,maxHistogram;
	static POINT *DomainPoints;
	static int DomainsCount;
	static int *mark,markCount;

	switch(message){
		case WM_CREATE:
			//hInstance = GetWindowsLong(hwnd,GWL_HINSTANCE);
			hInstance = ((LPCREATESTRUCT) lParam)->hInstance;
			//hBitmap = LoadBitmap(hInstance, MSKEINTRESOURCE(IDC_BITMAP));
			hBitmap = LoadImage(hInstance,filename,IMAGE_BITMAP,0,0,LR_LOADFROMFILE);
			GetObject(hBitmap,sizeof(BITMAP),&bitmap);
			bitmap.bmBits=(BYTE*)malloc(bitmap.bmWidthBytes*bitmap.bmHeight);
			GetBitmapBits(hBitmap,bitmap.bmWidthBytes*bitmap.bmHeight,bitmap.bmBits);
			pOrigin = (BYTE*)malloc(bitmap.bmWidthBytes*bitmap.bmHeight);
			GetBitmapBits(hBitmap,bitmap.bmWidthBytes*bitmap.bmHeight,pOrigin);
			return 0;
		case WM_PAINT:
			hdc = BeginPaint(hwnd, &ps);
			hdcMem = CreateCompatibleDC(hdc);
			SelectObject(hdcMem,hBitmap);
			BitBlt(hdc,0,0,bitmap.bmWidth,bitmap.bmHeight,hdcMem,0,0,SRCCOPY);
			DeleteDC(hdcMem);
			// 	sprintf(buf,"%d  %p",bitmap.bmWidth,pMap);
			// 	TextOut(hdc,100,140,buf,strlen(buf));
			//  if(pMap)ShowImage(hdc,bitmap,pMap);
			//  if(markCount){
			//  	int count =0;
			//  	for(int i=0;i<markCount;i++){
			//  		sprintf(buf,"(%d %d)",DomainPoints[i].x,DomainPoints[i].y);
			//  		TextOut(hdc,10+i/50*50,250+i%50*8,buf,strlen(buf));
			//  		if(mark[i]==i)count++;
			//  	}
			//  	sprintf(buf,"labelCount =  %d count = %d ",markCount,count);
			//  	TextOut(hdc,0,770,buf,strlen(buf));
			//  }
			/*
			if(markCount){
				HFONT hFont = CreateFont(-8,-4,0,0,0,0,0,0,0,0,0,0,0,0);
				HFONT hOldFont = SelectObject(hdc,hFont);
				int count =0;
				for(int i=0;i<markCount;i++){
					sprintf(buf,"(%d %d)",DomainPoints[i].x,DomainPoints[i].y);
					TextOut(hdc,10+i/50*50,250+i%50*8,buf,strlen(buf));
					Ellipse(hdc,DomainPoints[i].x-2,DomainPoints[i].y-2,DomainPoints[i].x+2,DomainPoints[i].y+2);
					if(mark[i]==i){
						
						count++;
					}
				}
				SelectObject(hdc,hOldFont);
				sprintf(buf,"labelCount =  %d count = %d ",markCount,count);
				TextOut(hdc,0,770,buf,strlen(buf));
				
				DeleteObject(hFont);
			}*/
			//StretchBlt(hdc,300,0,bitmap.bmWidth*3,bitmap.bmHeight*3,hdc,0,0,bitmap.bmWidth,bitmap.bmHeight,SRCCOPY);

			EndPaint(hwnd,&ps);
			return 0;
		case WM_KEYDOWN:
			switch(wParam){
				case VK_ESCAPE:
					PostMessage(hwnd,WM_DESTROY,0,0);
					break;
				case VK_F2:					
					memcpy(bitmap.bmBits,pOrigin,bitmap.bmWidthBytes*bitmap.bmHeight);
					break;
				case VK_F3:
					memcpy(bitmap.bmBits,pOrigin,bitmap.bmWidthBytes*bitmap.bmHeight);
					GreyBmp(&bitmap);
					break;
				case VK_F4:
					memcpy(bitmap.bmBits,pOrigin,bitmap.bmWidthBytes*bitmap.bmHeight);
					GreyBmp(&bitmap);
					GetHistogram(&bitmap,histogram,histogramSize,&avHistogram,&maxHistogram);
					BinaryBmp(&bitmap,(BYTE)avHistogram);
					break;
				case VK_F5:
					memcpy(bitmap.bmBits,pOrigin,bitmap.bmWidthBytes*bitmap.bmHeight);
					GreyBmp(&bitmap);
					GetHistogram(&bitmap,histogram,histogramSize,&avHistogram,&maxHistogram);
					BinaryBmp(&bitmap,(BYTE)avHistogram);				
					GetDomain( &bitmap, &pImage, &pMap,&DomainsCount,&DomainPoints,&mark,&markCount);
					break;
				case VK_F6:
					memcpy(bitmap.bmBits,pOrigin,bitmap.bmWidthBytes*bitmap.bmHeight);
					GreyBmp(&bitmap);
					GetHistogram(&bitmap,histogram,histogramSize,&avHistogram,&maxHistogram);
					BinaryBmp(&bitmap,(BYTE)avHistogram);				
					GetDomain( &bitmap, &pImage, &pMap,&DomainsCount,&DomainPoints,&mark,&markCount);
					GetEdge(&bitmap,&pImage);
					break;
			}
			SetBitmapBits(hBitmap,bitmap.bmWidthBytes*bitmap.bmHeight,bitmap.bmBits);
			InvalidateRect(hwnd,NULL,FALSE);
			return 0;	
		case WM_DESTROY:
			if(mark)free(mark);
			if(pImage)free(pImage);
			if(pMap)free(pMap);
			if(bitmap.bmBits)free(bitmap.bmBits);
			if(pOrigin)free(pOrigin);
			PostQuitMessage(0);
			return 0;
	}
	return DefWindowProc(hwnd, message,wParam,lParam);
}

VOID BinaryBmp(BITMAP *pBmp,BYTE threshold){
	BYTE *p,val;
	p=pBmp->bmBits;
	for(int y=0;y<pBmp->bmHeight;y++){
		p=pBmp->bmBits + pBmp->bmWidthBytes*y;
		for(int x=0;x<pBmp->bmWidth;x++,p+=4){
			if(*p>threshold){*p=*(p+1)=*(p+2)=0xFF;}
			else{*p=*(p+1)=*(p+2)=0x00;}
		}
	}
}

//将二值图的连通区域 标记 为不同颜色

VOID GetDomain( BITMAP *pBmp, BYTE **Image, int **map, int *DomainsCount, POINT **seeds,int **mark,int *labelcount){
	// 1 获取图片的Image矩阵

	int width, height;
	width=pBmp->bmWidth,height = pBmp->bmHeight;
	*Image = (BYTE*)malloc(width*height*sizeof(BYTE));
	BYTE *p,*q= *Image;
	for(int y=0;y<height;y++){
		p = pBmp->bmBits + pBmp->bmWidthBytes * y;
		for(int x=0; x<width; x++,p+=4,q++){
			*q = (0xFF-*p)/0xFF;
		}
	}
	
	// 2 在Image矩阵上做连通标记	
	// ConnectedLabeling(Image,labelmap,width,height,8,pAddress);
	int domainSize;
	int x,y,d,u,v;
	int dx[8]={ -1, -1,  0,  1,  1,  1,  0, -1 };
	int dy[8]={  0, -1, -1, -1,  0,  1,  1,  1 };
	int *r,*s;
	BYTE *t;

	POINT **label_list = (POINT**)malloc(100*sizeof(POINT*));
	for(int i=0;i<100;i++){
		label_list[i] = (POINT*)malloc(100*sizeof(POINT));
		memset(label_list[i],0,100*sizeof(POINT));
	}

	*map = (int*)malloc( width*height*sizeof(int) );
	memset(*map,0,width*height*sizeof(int));

	*mark = (int*)malloc(600*sizeof(int));
	memset(*mark,0,600*sizeof(int));
	*seeds = (POINT*)malloc(600*sizeof(POINT));
	memset(*seeds,0,600*sizeof(POINT));

	int label, cnt, min,max,dt;

	//  (1) 第一次扫描：
	//      访问当前像素B(x,y)，如果B(x,y) == 1：
	//      a、如果B(x,y)的领域中像素值都为0，则赋予B(x,y)一个新的label：
	//         label += 1， B(x,y) = label；
	//			mark[label]=0;

	//      b、如果B(x,y)的领域中有像素值 > 1的像素Neighbors：
	//         1）将Neighbors中的最小值赋予给B(x,y):
	//            B(x,y) = min{Neighbors} 

	//         2）记录Neighbors中各个值（label）之间的相等关系，即这些值（label）同属同一个连通区域；
	//            labelSet[i] = { label_m, .., label_n }，
	//            labelSet[i]中的所有label都属于同一个连通区域
	//            （注：这里可以有多种实现方式，只要能够记录这些具有相等关系的label之间的关系即可）
	//			if(label>min)mark[label]=min;

	//  (2) 第二次扫描：
	//      访问当前像素B(x,y)，如果B(x,y) > 1：
	//      a 找到与label = B(x,y)同属相等关系的一个最小label值，赋予给B(x,y)；

	//      完成扫描后，图像中具有相同label值的像素就组成了同一个连通区域。
	
	// round 1 
	q = *Image;
	r = *map;
	dt = 0;label=0;
	for(int y=0; y<height; y++){
		for(int x=0; x<width; x++, r++, q++){
			if(*q){//只标注图像点
				cnt=0;//点(x,y)邻域中标注过的点的个数
				min=100;                  // 1  2  4
				for(d=0;d<4;d++){         // 0  x
					u=x+dx[d],v=y+dy[d];
					if(0<=u && u<width && 0<=v && v<height){
						s = *map + v * width + u;
						cnt += *s;
						if(*s>0 && min>*s){
							min=*s;
						}
					}
				}

				if(cnt==0){//如果邻域没有区域点，则区域计数加1
					label++;
					*r=label;//标注区域编号
					(*mark)[label]=label;

					(*seeds)[label].x=x;
					(*seeds)[label].y=y;


					//keep new label list
					
				}else{
					// 1）将Neighbors中的最小值赋予给B(x,y): B(x,y) = min{Neighbors}
					*r=min;

					//   ========  The Algorithm of Keeping equal label table ========= 	
					// 2）记录Neighbors中各个值（label）之间的相等关系，即这些值（label）属于同一个连通区域；
					// labelSet[i] = { label_m, .., label_n }，
					// labelSet[i]中的所有label都属于同一个连通区域
					//（注：这里可以有多种实现方式，只要能够记录这些具有相等关系的label之间的关系即可）
					for(d=0;d<4;d++){
						u=x+dx[d],v=y+dy[d];
						if(0<=u && u<width && 0<=v && v<height){
							s = *map + v * width + u;
							if(*s && (*mark)[*s] > *r)
								(*mark)[*s]=*r;
						}
					}					
				}				
			}
		}
	}

	// Merge the equal label table
	*DomainsCount = *labelcount=label+1;
	for(int i=1;i<label+1;i++){
		int j=i;
		while((*mark)[j]!=j){
			(*mark)[j] = (*mark)[(*mark)[j]];
			j--;
		}
	}

	// round 2

	r = *map;
	for(int y=0; y<height; y++){
		for(int x=0; x<width; x++, r++){
			*r=(*mark)[*r];
		}
	}	


	//Restore map to Image	
	q = *Image;
	r = *map;
	for(int y=0; y<height; y++){
		for(int x=0; x<width; x++, r++, q++){
			*q = *r;
		}
	}

	// 3 根据image矩阵的标记给bitmap着色
	q = *Image;
	BYTE color[10][3]={  {0xFF,0xFF,0xFF},{0x80,0xFF,0x00},{0xFF,0x00,0x00},{0xFF,0x00,0xFF},{0x80,0x00,0xFF},
			     {0x00,0xFF,0x00},{0x00,0xFF,0xFF},{0x00,0xFF,0x80},{0x00,0x80,0xFF},{0x00,0x80,0x80} };
	for(int y=0;y<height;y++){
		p = pBmp->bmBits + pBmp->bmWidthBytes * y;
		for(int x=0; x<width; x++,p+=4,q++){
			if(*q){
				*p=color[(*q)%9+1][0];
				*(p+1)=color[(*q)%9+1][1];
				*(p+2)=color[(*q)%9+1][2];
			}
		}
	}
}
VOID GetEdge(BITMAP *pBmp,BYTE **Image){
	int width, height;
	int x, y, d, u, v;
	BYTE *p, *q;
	width = pBmp->bmWidth, height = pBmp->bmHeight;

	int dx[8]={ -1, -1,  0,  1,  1,  1,  0, -1 };
	int dy[8]={  0, -1, -1, -1,  0,  1,  1,  1 };
	BYTE *map = (BYTE*)malloc(width*height*sizeof(BYTE));
	memcpy(map,*Image,width*height*sizeof(BYTE));
	q = *Image;p=map;
	for(int y=0;y<height;y++){
		//p = pBmp->bmBits + pBmp->bmWidthBytes * y;
		for(int x=0; x<width; x++,p++,q++){
			if(*p){
				int sum=0;
				BYTE *s;
				for(d=0;d<8;d++){
					u=x+dx[d],v=y+dy[d];
					if(0<u && u<width && 0<v && v<height){
					s=map + v*width + u;
					sum += (*s>0);}
				}
				if(sum==0 || sum==8)*q = 0; //if the dot is not on Edge, set to zero.
			}
		}
	}
	memset(pBmp->bmBits,0xFF,pBmp->bmWidthBytes*pBmp->bmHeight);
	q = *Image;
	for(int y=0;y<height;y++){
		p = pBmp->bmBits + pBmp->bmWidthBytes * y;
		for(int x=0; x<width; x++,p+=4,q++){
			if(*q){ //set the dot to red color
				*p=0;
				*(p+1)=0;
				*(p+2)=0XFF;
			}
		}
	}		
	free(map);
}
VOID GetHistogram(BITMAP *pBmp, int *histogram, int histogramSize, int *avHistogram, int *maxHistogram){
	BYTE *p,val;
	int sum=0,max=0;
	if(histogram==NULL){
		histogram = (int*)malloc(histogramSize*sizeof(int));
	}
	memset(histogram,0,histogramSize*sizeof(int));

	p=pBmp->bmBits;
	for(int y=0;y<pBmp->bmHeight;y++){
		p=pBmp->bmBits + pBmp->bmWidthBytes*y;
		for(int x=0;x<pBmp->bmWidth;x++,p+=4){
			sum+=*p;
			histogram[*p]++;
		}
	}
	*avHistogram = sum/(pBmp->bmHeight * pBmp->bmWidth);
	for(int i=0;i<histogramSize;i++){
		if(max < histogram[i])max = histogram[i];
	}
	*maxHistogram = max;
}
VOID GreyBmp(BITMAP *pBmp){
	BYTE *p,val;
	p=pBmp->bmBits;
	for(int y=0;y<pBmp->bmHeight;y++){
		p=pBmp->bmBits + pBmp->bmWidthBytes*y;
		for(int x=0;x<pBmp->bmWidth;x++,p+=4){
			//Y' = 0.299 R' + 0.587 G' + 0.114 B'   sRGB  5:6:5
			//Y' = 0.2126 R' + 0.7152 G' + 0.0722 B'
			val = (BYTE)(*p*0.114+*(p+1)*0.587+*(p+2)*0.229);
			*p=*(p+1)=*(p+2)=val;
		}
	}	
}

VOID ShowBmpInfo(HWND hwnd,BITMAP *pBmp){
	HDC hdc = GetDC(hwnd);
	char buf[100];

	sprintf(buf,"bmType = %04X %d",pBmp->bmType,pBmp->bmType);
	TextOut(hdc,600,0,buf,strlen(buf));
	sprintf(buf,"bmWidth = %04X %d",pBmp->bmWidth,pBmp->bmWidth);
	TextOut(hdc,600,20,buf,strlen(buf));
	sprintf(buf,"bmHeight = %04X %d",pBmp->bmHeight,pBmp->bmHeight);
	TextOut(hdc,600,40,buf,strlen(buf));
	sprintf(buf,"bmWidthBytes = %04X %d",pBmp->bmWidthBytes,pBmp->bmWidthBytes);
	TextOut(hdc,600,60,buf,strlen(buf));
	sprintf(buf,"bmPlanes = %04X %d",pBmp->bmPlanes,pBmp->bmPlanes);
	TextOut(hdc,600,80,buf,strlen(buf));
	sprintf(buf,"bmBitsPixel = %04X %d",pBmp->bmBitsPixel,pBmp->bmBitsPixel);
	TextOut(hdc,600,100,buf,strlen(buf));
	sprintf(buf,"bmBits = %04X %d",pBmp->bmBits,pBmp->bmBits);
	TextOut(hdc,600,120,buf,strlen(buf));
	sprintf(buf,"LONG = %04X %d",sizeof(LONG),sizeof(LONG));
	TextOut(hdc,600,140,buf,strlen(buf));
	sprintf(buf,"LONG LONG = %04X %d",sizeof(long long),sizeof(long long));
	TextOut(hdc,600,160,buf,strlen(buf));
	ReleaseDC(hwnd,hdc);
}
VOID ShowImage(HDC hdc, BITMAP bitmap, int *pMap){
	char buf[100];
	HFONT hFont = CreateFont(-8,-4,0,0,0,0,0,0,0,0,0,0,0,0);
	SelectObject(hdc,hFont);
	for(int y=0;y<bitmap.bmHeight;y++){
		for(int x=0;x<bitmap.bmWidth;x++){
			if(*(pMap+y*bitmap.bmWidth+x)){
				sprintf(buf,"%d",*(pMap+y*bitmap.bmWidth+x));
				TextOut(hdc,300+x*8,y*8,buf,strlen(buf));
			}else{
				TextOut(hdc,300+x*8,y*8,".",1);
			}
		}
		sprintf(buf,"%d",y);
		TextOut(hdc,280,y*8,buf,strlen(buf));
	}
	DeleteObject(hFont);
}
VOID TracingEdge( BITMAP *pBmp, BYTE **Image, POINT pt, POINT **EdgePoint, int *EdgePointCount,BYTE **linkCode ){

	// char buf[100];

    //int rowMoves[] = {0, 1, 0, -1};
    //int colMoves[] = {1, 0, -1, 0};	

    int rowMoves[] = {  0, -1, -1, -1,  0,  1,  1,  1 };
    int colMoves[] = { -1, -1,  0,  1,  1,  1,  0, -1 };   

	int MAX_ROWS,MAX_COLS;
	int numCols = pBmp->bmWidth;
	int numRows = pBmp->bmHeight;
	int startRow = pt.y, startCol = pt.x;

	int **visited = (int**)malloc(numRows * sizeof(int*));
	for(int i=0;i<numRows;i++){
		visited[i]=(int*)malloc(numCols * sizeof(int));
		memset(visited[i],0,numCols * sizeof(int));
	}

	visited[startRow][startCol]=1;

	int currentRow = startRow;
	int currentCol = startCol;
	
	*EdgePoint = (POINT*)malloc(100000*sizeof(POINT));
	*linkCode = (BYTE*)malloc(100000*sizeof(BYTE));

	int k=0,dt=0,l=0,count=0;
	int nextRow;
	int nextCol;
	BOOL stop = FALSE;

	do{
		//process the current position which is an EdgePoint. 
		if(count!=8){k=l;//use l to remember where the last edge segment line stops.
			(*EdgePoint)[k].x = currentCol; (*EdgePoint)[k].y = currentRow;
			k++;l=k;
		}

		 // Check the possible moves in clockwise order
		count=0;
		for(int d=dt;d<dt+8;d++){
			nextRow = currentRow + rowMoves[d%8];
			nextCol = currentCol + colMoves[d%8];
			count++;

			//stop if the next position goes to the beginning.
			if(nextRow == startRow && nextCol == startCol){
				(*linkCode)[k] = d%8; stop = TRUE;
			} 

			// Skip if the next position is out of bounds
			if (nextRow < 0 || nextRow >= numRows || nextCol < 0 || nextCol >= numCols)
                continue;
			
            // Skip if the next position is not an edge pixel or it has been visited before
			if ( (*Image)[nextRow * numCols + nextCol] != 1 || visited[nextRow][nextCol] == 1 )
				continue;
			// Move to the next position
			(*Image)[nextRow * numCols + nextCol]=2;
			(*linkCode)[k-1] = d%8;
			currentRow = nextRow;
            currentCol = nextCol;
            visited[currentRow][currentCol] = 1;
            dt=(d+5)%8;
            break;
		}
		if(count==8){ // back trace if there is no edge point in the neighborhood.
			if(l==k)(*linkCode)[k-1] = 0xFF;
			sprintf(buf," (%d %d) dt=%d k=%d \n No Edge point from here.",currentCol,currentRow,dt,k );
			MessageBox(NULL,buf,"KK",MB_OK);
			k--;dt=((*linkCode)[k]+1)%8;
			currentCol = (*EdgePoint)[k].x; currentRow = (*EdgePoint)[k].y;
		}
	}while(!stop );
	*EdgePointCount = k;
	ImgToBmp(pBmp,Image);
}
//----------------------------------------------------------------------------------------------------------------------------------------
// edge.c
// gcc edge.c -oedge.exe -mwindows
// 2023-08-05 by programfanny 

#include <windows.h>
#include <stdio.h>

VOID BinaryBmp(BITMAP bitmap, BYTE **Image, BYTE threshold);
VOID BitmapToImage(BITMAP bitmap, BYTE* Image);

VOID GetDomain(BITMAP bitmap, BYTE **Image);
VOID GetDomain2(BITMAP bitmap, BYTE **Image, POINT **point,int *markCount);
VOID GetDomain3(HWND hwnd, BITMAP bitmap, BYTE **Image, int **mark,POINT **point,int *markCount);

VOID GetEdge ( BITMAP bitmap,BYTE **pImage,POINT *point,int markCount );
VOID GetEdge2( BITMAP bitmap,BYTE **pImage,POINT **edge,int *EdgePointCount, BYTE **LinkCode, POINT *point,int markCount );

VOID GetHistogram(BITMAP bitmap,int *histogram, int histogramSize,int *avHistogram, int *maxHistogram);
VOID GreyBmp(BITMAP bitmap);
VOID ImageToBitmap(BITMAP bitmap,BYTE *Image);

VOID ShowDataByte(HWND hwnd, BYTE *DataBuf, int page, int xPos, int yPos);
VOID ShowEdgeData(HWND hwnd, POINT *EdgePoint,BYTE*LinkCode,int EdgePointCount);
VOID ShowMarkData(HWND hwnd, POINT *point, int markCount, int xPos, int yPos);
VOID ShowMarkData2(HWND hwnd, int *MARK, POINT *point, int markCount, int xPos, int yPos);

LRESULT CALLBACK WndProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);
int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, PSTR szCmdLine, int iCmdShow){
	static TCHAR szAppName[] = TEXT("HelloWin");
	HWND hwnd;
	MSG msg;
	WNDCLASS wndclass;
	wndclass.style = CS_HREDRAW | CS_VREDRAW;
	wndclass.lpfnWndProc = WndProc;
	wndclass.cbClsExtra = 0;
	wndclass.cbWndExtra = 0;
	wndclass.hInstance = hInstance;
	wndclass.hIcon = LoadIcon(NULL,IDI_APPLICATION);
	wndclass.hCursor = LoadCursor(NULL,IDC_ARROW);
	wndclass.hbrBackground = (HBRUSH)GetStockObject(WHITE_BRUSH);
	wndclass.lpszMenuName = NULL;
	wndclass.lpszClassName = szAppName;
	if(!RegisterClass(&wndclass)){
		MessageBox(NULL,TEXT("This program requires Windows NT!"), szAppName, MB_ICONERROR);
		return 0;
	}
	hwnd = CreateWindow(szAppName,TEXT("The Hello Program"),WS_OVERLAPPEDWINDOW,CW_USEDEFAULT,CW_USEDEFAULT,CW_USEDEFAULT,CW_USEDEFAULT,NULL,NULL,hInstance,NULL);
	ShowWindow(hwnd,iCmdShow);
	UpdateWindow(hwnd);
	while(GetMessage(&msg,NULL,0,0)){
		TranslateMessage(&msg);
		DispatchMessage(&msg);
	}
	return msg.wParam;
}
LRESULT CALLBACK WndProc(HWND hwnd, UINT message,WPARAM wParam,LPARAM lParam){
	HANDLE hInstance;
	HDC hdc,hdcMem;
	PAINTSTRUCT ps;
	RECT rect;
	HFONT hFont;
	char buf[100];
	// static LPCSTR filename = "shapes.bmp";
	// static LPCSTR filename = "gear.bmp";
	// static LPCSTR filename = "rooster.bmp";
	 static LPCSTR filename = "rice02.bmp";
	// static LPCSTR filename = "gears.bmp";	 

	static HBITMAP hBitmap;

	static BITMAP bitmap;
	static BYTE *pMap, *pOrigin, *pImage ;
	// black = 0  white = 1 in Image Data
	// background = 0  foreground = 1
	
	static int *histogram,histogramSize=256,avHistogram,maxHistogram;
	
	static POINT *DomainPoints;
	static int DomainsCount;
	static int markCount, *mark;
	static POINT *point;

	static POINT *EdgePoint;
	static int EdgePointCount=0;
	static BYTE *LinkCode;

	static DWORD curPage=0,maxPage;
	static int path=0;

	int x,y;
	POINT pt;

	switch(message){
		case WM_CREATE:
			//hInstance = GetWindowsLong(hwnd,GWL_HINSTANCE);
			hInstance = ((LPCREATESTRUCT) lParam)->hInstance;
			//hBitmap = LoadBitmap(hInstance, MSKEINTRESOURCE(IDC_BITMAP));
			hBitmap = LoadImage(hInstance,filename,IMAGE_BITMAP,0,0,LR_LOADFROMFILE);
			GetObject(hBitmap,sizeof(BITMAP),&bitmap);
			bitmap.bmBits=(BYTE*)malloc(bitmap.bmWidthBytes*bitmap.bmHeight);
			GetBitmapBits(hBitmap,bitmap.bmWidthBytes*bitmap.bmHeight,bitmap.bmBits);
			pOrigin = (BYTE*)malloc(bitmap.bmWidthBytes*bitmap.bmHeight);
			GetBitmapBits(hBitmap,bitmap.bmWidthBytes*bitmap.bmHeight,pOrigin);
			maxPage = (bitmap.bmWidth*bitmap.bmHeight+511)/512;
			curPage=0;
			return 0;
		case WM_PAINT:
			hdc = BeginPaint(hwnd, &ps);
			hdcMem = CreateCompatibleDC(hdc);
			SelectObject(hdcMem,hBitmap);
			BitBlt(hdc,0,0,bitmap.bmWidth,bitmap.bmHeight,hdcMem,0,0,SRCCOPY);
			DeleteDC(hdcMem);
			sprintf(buf,"%d",markCount);
			TextOut(hdc,300,300,buf,strlen(buf));

			// ShowDataByte( hwnd, pImage, curPage, bitmap.bmWidth+20, 10);
			// switch(path){
			// 	case 1:
			// 		ShowMarkData( hwnd, point, markCount, bitmap.bmWidth+20, 350);
			// 		break;
			// 	case 2:
			// 		ShowMarkData2( hwnd, mark, point, markCount, bitmap.bmWidth+20, 350);
			// 		break;
			// }

			//if(EdgePointCount){
			//	ShowEdgeData(hwnd,EdgePoint,LinkCode,EdgePointCount);
			//}

			EndPaint(hwnd,&ps);
			return 0;
		case WM_KEYDOWN:
			switch(wParam){
				case VK_ESCAPE:
					PostMessage(hwnd,WM_DESTROY,0,0);
					break;
				case VK_F1:
					strcpy(buf,"F1 - Show this Message\n");
					strcat(buf,"F2 - Orginal Image\n");
					strcat(buf,"F3 - Grey the Image\n");
					strcat(buf,"F4 - Binary the Image\n");
					strcat(buf,"F5 - Get the Domain From Image\n");
					strcat(buf,"F6 - Get the Edge by corrosion\n");
					strcat(buf,"F7 - Trace the Edge & LinkCode\n");
					strcat(buf,"F8 - \n");
					MessageBox(NULL,buf,"Help",MB_OK);
					break;	
				case VK_F2:
					memcpy(bitmap.bmBits,pOrigin,bitmap.bmWidthBytes*bitmap.bmHeight);
					break;
				case VK_F3:
					memcpy(bitmap.bmBits,pOrigin,bitmap.bmWidthBytes*bitmap.bmHeight);
					GreyBmp(bitmap);
					break;
				case VK_F4:
					memcpy(bitmap.bmBits,pOrigin,bitmap.bmWidthBytes*bitmap.bmHeight);
					GreyBmp(bitmap);
					GetHistogram(bitmap,histogram,histogramSize,&avHistogram,&maxHistogram);
					BinaryBmp(bitmap,&pImage,(BYTE)(avHistogram*2/3));
					break;
				case VK_F5:
					memcpy(bitmap.bmBits,pOrigin,bitmap.bmWidthBytes*bitmap.bmHeight);
					GreyBmp( bitmap );
					GetHistogram( bitmap, histogram, histogramSize, &avHistogram, &maxHistogram);
					BinaryBmp( bitmap,&pImage, (BYTE)(avHistogram*2/3));
					GetDomain( bitmap, &pImage );
					path=0;
					break;
				case VK_F6:
					memcpy(bitmap.bmBits,pOrigin,bitmap.bmWidthBytes*bitmap.bmHeight);
					GreyBmp( bitmap );
					GetHistogram( bitmap, histogram, histogramSize, &avHistogram, &maxHistogram);
					BinaryBmp( bitmap,&pImage, (BYTE)(avHistogram*5/5));
					GetDomain2( bitmap, &pImage, &point, &markCount );
					path=1;
					break;
				case VK_F7:
					memcpy( bitmap.bmBits,pOrigin,bitmap.bmWidthBytes*bitmap.bmHeight );
					GreyBmp( bitmap );
					GetHistogram( bitmap, histogram, histogramSize, &avHistogram, &maxHistogram );
					BinaryBmp( bitmap,&pImage, (BYTE)(avHistogram*2/3) );
					GetDomain3( hwnd, bitmap, &pImage, &mark,&point, &markCount );
					path=2;
					GetEdge( bitmap, &pImage, point, markCount );
					break;
				case VK_F8:					
					memcpy( bitmap.bmBits,pOrigin,bitmap.bmWidthBytes*bitmap.bmHeight );
					GreyBmp( bitmap );
					GetHistogram( bitmap, histogram, histogramSize, &avHistogram, &maxHistogram );
					BinaryBmp( bitmap, &pImage,(BYTE)(avHistogram*2/3) );
					GetDomain3( hwnd, bitmap, &pImage, &mark,&point, &markCount );
					path=2;
					GetEdge2( bitmap, &pImage, &EdgePoint,&EdgePointCount, &LinkCode, point, markCount );
					break;
				case VK_F9:
					MessageBox(NULL,"You pressed F9","Press",MB_OK);
					break;
				case VK_PRIOR:
					curPage--;
					if(curPage==0xFFFFFFFF)curPage=maxPage-1;
					break;
				case VK_NEXT:
					curPage++;
					if(curPage==maxPage)curPage=0;
					break;

			}
			SetBitmapBits(hBitmap,bitmap.bmWidthBytes*bitmap.bmHeight,bitmap.bmBits);
			InvalidateRect(hwnd,NULL,TRUE);
			return 0;
		case WM_RBUTTONDOWN:
			x=LOWORD(lParam);y=HIWORD(lParam);
			hdc = GetDC(hwnd);
			StretchBlt(hdc,0,400,110,110,hdc,x-5,y-5,11,11,SRCCOPY);
			ReleaseDC(hwnd,hdc);
			return 0;		
		case WM_DESTROY:
			if(point)free(point);
			if(EdgePoint)free(EdgePoint);
			if(LinkCode)free(LinkCode);
			if(pImage)free(pImage);
			if(pMap)free(pMap);
			if(bitmap.bmBits)free(bitmap.bmBits);
			if(pOrigin)free(pOrigin);
			PostQuitMessage(0);
			return 0;
	}
	return DefWindowProc(hwnd, message,wParam,lParam);
}

VOID BinaryBmp(BITMAP bitmap, BYTE **Image, BYTE threshold){
	BYTE *p;
	// Filter()
	//BYTE *q;
	//BYTE *Image=(BYTE*)malloc(bitmap.bmWidth*bitmap.bmHeight*sizeof(BYTE));

	for(int y=0;y<bitmap.bmHeight;y++){
		p=bitmap.bmBits + y*bitmap.bmWidthBytes;
		for(int x=0;x<bitmap.bmWidth;x++,p+=4){			
			if(*p>threshold){
				p[0] = p[1]= p[2]=0xFF;
			}else{
				p[0] = p[1]= p[2]=0x00;
			}
		}
	}
}
VOID BitmapToImage(BITMAP bitmap, BYTE* image){
	BYTE *p,*q;
	q=image;p=bitmap.bmBits;
	if(*p==0xFF){
		for(int y=0;y<bitmap.bmHeight;y++){		
			for(int x=0;x<bitmap.bmWidth;x++,q++){
				*q = (0xFF-*(p+4*x))/0xFF; // Inverse case // white -> 0 display : black , background  black->1 display : white , foreColor
			}
			p += bitmap.bmWidthBytes;
		}
	}else{
		for(int y=0;y<bitmap.bmHeight;y++){		
			for(int x=0;x<bitmap.bmWidth;x++,q++){
				*q=*(p+4*x)/0xFF;     //  Normal case       // black -> 0 display : black , background  white->1 display : white , foreColor
			}
			p += bitmap.bmWidthBytes;
		}		
	}
}

typedef struct tag_domain{
	POINT pt;
	struct tag_domain *next;
}DOMAIN;

VOID GetDomain ( BITMAP bitmap, BYTE **Image ){
	// 区域填充
	BYTE *map;
	BYTE *p,*s;
	int width = bitmap.bmWidth,height=bitmap.bmHeight;
	
	int domainSize;
	int x, y, d, u, v;
	int dx[8] = { -1, -1,  0,  1,  1,  1,  0, -1 };
	int dy[8] = {  0, -1, -1, -1,  0,  1,  1,  1 };
	
	int label, cnt, min,max,dt;
	DOMAIN *DomainList = NULL, *pDomain,*qDomain;

	if(*Image == NULL)*Image = (BYTE*)malloc(width*height*sizeof(BYTE));

	BitmapToImage(bitmap,*Image);

	int *mark=(int*)malloc(width*height*sizeof(int));

	p= *Image; label = 0;
	qDomain = DomainList;

	for(int y = 0; y < height; y++){
		for(int x = 0; x < width; x++, p++){
			if(*p==0)continue;
			cnt=0; min=1000;
			for(d=0; d<4; d++){
				u=x+dx[d],v=y+dy[d];
				if( 0 <= u && u < width && 0 <= v && v < height ){
					s = *Image + v * width + u;
					cnt += *s;
					if(*s>0 && min>*s){
						min=*s;
					}
				}
			}
			
			if(cnt==0){
				pDomain = (DOMAIN*)malloc(sizeof(DOMAIN));
				pDomain->next = qDomain;
				pDomain->pt.x = x, pDomain->pt.y = y;
				qDomain = pDomain;

				label++;
				*p = label;
				mark[label] = label;
			}else{
				*p=min;				
				for(d=0;d<4;d++){
					u=x+dx[d],v=y+dy[d];
					if(0<=u && u<width && 0<=v && v<height){
						s = *Image + v * width + u;
						if(*s && mark[*s] > min)
							mark[*s] = min;
					}
				}
			}
		}
	}
	domainSize = label+1;
	for(int i=0;i<domainSize;i++){
		int j=i;
		while(mark[j]!=j){
			mark[j]=mark[mark[j]];
			j--;
		}
	}
	p = *Image;
	for(int y=0;y<height;y++){
		for(int x=0;x<width;x++,p++){
			*p=mark[*p];
		}
	}

	ImageToBitmap( bitmap, *Image );

	free(mark);
}
// Get Domain count and return a seed point for each domain. Fill the domain in different colors 
VOID GetDomain2 ( BITMAP bitmap, BYTE **Image, POINT** point, int *markCount){
	// 区域填充
	BYTE *map;
	BYTE *p,*q;
	int width = bitmap.bmWidth,height=bitmap.bmHeight;
	
	int domainSize;
	int x, y, d, u, v;
	int dx[8] = { -1, -1,  0,  1,  1,  1,  0, -1 };
	int dy[8] = {  0, -1, -1, -1,  0,  1,  1,  1 };
	int of[8] = { -1, -width-1, -width, -width+1, 1, width+1, width, width-1 };
	BYTE *r, *s, *t;
	int label, cnt, min,max,dt;

	if(*Image == NULL)*Image = (BYTE*)malloc(width*height*sizeof(BYTE));

	BitmapToImage(bitmap,*Image);

	int *mark=(int*)malloc(width*height*sizeof(int));
	*point = (POINT*)malloc(width*height*sizeof(POINT));
	memset(mark,0,width*height*sizeof(int));
	memset(*point,0,width*height*sizeof(POINT));

	p= *Image; label = 0;

	for(int y = 0; y < height; y++){
		for(int x = 0; x < width; x++, p++){
			if(*p==0) continue;
			cnt=0; min=1000;
			for(d=0; d<4; d++){
				u=x+dx[d],v=y+dy[d];
				if( 0 <= u && u < width && 0 <= v && v < height ){
					s = *Image + v * width + u;
					cnt += *s;
					if(*s>0 && min>*s){
						min=*s;
					}
				}
			}
			
			if(cnt==0){
				label++;
				*p = label;
				mark[label] = label;
				(*point)[label].x=x;
				(*point)[label].y=y;
				
			}else{
				*p=min;				
				for(d=0;d<4;d++){
					u=x+dx[d],v=y+dy[d];
					if(0<=u && u<width && 0<=v && v<height){
						s = *Image + v * width + u;
						if(*s && mark[*s] > min)
							mark[*s] = min;
					}
				}
			}
		}
	}

	// Combine the Connect mark 
	*markCount = domainSize = label+1;
		
	for(int i=0;i<domainSize;i++){
		int j=i;
		while(mark[j]!=j){
			mark[j]=mark[mark[j]];
			j--;
		}
	}

	// fill the image with the mark

	p = *Image;
	for(int y=0;y<height;y++){
		for(int x=0;x<width;x++,p++){
			*p=mark[*p];
		}
	}

	// Pack the  mark list and seed point
	int l=0;
	for(int i=0;i<*markCount;i++){
		if(mark[i]==i){
		mark[l]=l;	
		(*point)[l].x = (*point)[i].x;
		(*point)[l].y = (*point)[i].y;
		l++;
		}
	}

	*markCount = l;
	free(mark);

	ImageToBitmap( bitmap, *Image );
}
VOID GetDomain3 (HWND hwnd, BITMAP bitmap, BYTE **Image, int **mark, POINT** point,int *markCount){
	// 区域填充
	BYTE *map;
	BYTE *p,*q;
	int width = bitmap.bmWidth,height=bitmap.bmHeight;
	
	int domainSize;
	int x, y, d, u, v;
	int dx[8] = { -1, -1,  0,  1,  1,  1,  0, -1 };
	int dy[8] = {  0, -1, -1, -1,  0,  1,  1,  1 };
	int of[8] = { -1, -width-1, -width, -width+1, 1, width+1, width, width-1 };
	BYTE *r, *s, *t;
	int label, cnt, min,max,dt;

	if(*Image == NULL)*Image = (BYTE*)malloc(width*height*sizeof(BYTE));

	BitmapToImage(bitmap,*Image);

	if(*mark==NULL){
		*mark=(int*)malloc(width*height*sizeof(int));
		*point = (POINT*)malloc(width*height*sizeof(POINT));
	}
	memset(*mark,0,width*height*sizeof(int));
	memset(*point,0,width*height*sizeof(POINT));

	p= *Image; label = 0;

	for(int y = 0; y < height; y++){
		for(int x = 0; x < width; x++, p++){
			if(*p==0) continue;
			cnt=0; min=1000;
			for(d=0; d<4; d++){
				u=x+dx[d],v=y+dy[d];
				if( 0 <= u && u < width && 0 <= v && v < height ){
					s = *Image + v * width + u;
					cnt += *s;
					if(*s>0 && min>*s){
						min=*s;
					}
				}
			}
			
			if(cnt==0){
				label++;
				*p = label;
				(*mark)[label] = label;
				(*point)[label].x=x;
				(*point)[label].y=y;
				
			}else{
				*p=min;				
				for(d=0;d<4;d++){
					u=x+dx[d],v=y+dy[d];
					if(0<=u && u<width && 0<=v && v<height){
						s = *Image + v * width + u;
						if(*s && (*mark)[*s] > min)
							(*mark)[*s] = min;
					}
				}
			}
		}
	}

	// Combine the Connect mark 
	*markCount = domainSize = label+1;
		
	for(int i=0;i<domainSize;i++){
		int j=i;
		while((*mark)[j]!=j){
			(*mark)[j]=(*mark)[(*mark)[j]];
			j--;
		}
	}

	// fill the image with the mark

	p = *Image;
	for(int y=0;y<height;y++){
		for(int x=0;x<width;x++,p++){
			*p=(*mark)[*p];
		}
	}
	// Pack the  mark list and seed point
	int l=0;
	for(int i=0;i<*markCount;i++){
		if((*mark)[i]==i){
		(*mark)[l]=l;	
		(*point)[l].x = (*point)[i].x;
		(*point)[l].y = (*point)[i].y;
		l++;
		}
	}

	*markCount = l;

	ImageToBitmap( bitmap, *Image );
}

VOID GetEdge( BITMAP bitmap, BYTE **Image, POINT *point, int markCount ){
	BYTE *map,*p,*q,*s;
	int u,v;
	int dx[8]={ -1, -1,  0,  1,  1,  1,  0, -1 };
	int dy[8]={  0, -1, -1, -1,  0,  1,  1,  1 };

	if(*Image==NULL){
		*Image = (BYTE*)malloc( bitmap.bmWidth * bitmap.bmHeight * sizeof(BYTE) );
	}
	// BitmapToImage(bitmap,*Image);

	map = (BYTE*)malloc( bitmap.bmWidth * bitmap.bmHeight * sizeof(BYTE) );
	//memset( map, 0, bitmap.bmWidth * bitmap.bmHeight * sizeof(BYTE) );
	memcpy(map,*Image,bitmap.bmWidth * bitmap.bmHeight * sizeof(BYTE) );
	p=map; q=*Image;
	for(int y=0;y<bitmap.bmHeight;y++){
		for(int x=0;x<bitmap.bmWidth;x++,p++,q++){
			// 统计每个点周围像素点个数，
			// 若周围有8个像素点，则是内部点，像素值不变，
			// 若为0个，则为孤立点，抹去该点，像素值变为相邻点的像素值
			// 若为其他值，则是边界点，
			if(*q){
				int count=0;
				for(int d=0;d<8;d++){
					u=x+dx[d];v=y+dy[d];
					if(0<=u && u<bitmap.bmWidth && 0<=v && v<bitmap.bmHeight){
						s=*Image+v*bitmap.bmWidth+u;
						count += (*s>0);
					}
				}
				switch(count){
					case 0:
						*p=*s;
					break;
					case 8:
						*p=10;
					break;
					default:
						*p=*p+2;
						if(*p==0){*p=1;}
					break;
				}
			}
		}
	}

	memcpy(*Image, map, bitmap.bmWidth*bitmap.bmHeight*sizeof(BYTE));
	free(map);
	ImageToBitmap( bitmap, *Image );
}

// Trance the edge and get the link code for each domain from the point.
VOID GetEdge2( BITMAP bitmap,BYTE **Image, POINT **EdgePoint,int *EdgePointCount, BYTE **LinkCode,POINT *point, int markCount ){

	BYTE *map,*p,*q,*s,val;
	int x0,y0,x,y,u,v,off;
	int dx[8]={ -1, -1,  0,  1,  1,  1,  0, -1 };
	int dy[8]={  0, -1, -1, -1,  0,  1,  1,  1 };

	if(*Image==NULL){
		*Image = (BYTE*)malloc( bitmap.bmWidth * bitmap.bmHeight * sizeof(BYTE) );
		BitmapToImage(bitmap,*Image);	
	}

	map = (BYTE*)malloc( bitmap.bmWidth * bitmap.bmHeight * sizeof(BYTE) );
	
	memset( map, 10, bitmap.bmWidth * bitmap.bmHeight * sizeof(BYTE) );

	p=map; q=*Image;

	for(int i=markCount-1;i>0;i--){

		if(*EdgePoint==NULL)*EdgePoint = (POINT*)malloc(bitmap.bmWidth * bitmap.bmHeight * sizeof(POINT));
		memset( *EdgePoint, 0, bitmap.bmWidth * bitmap.bmHeight * sizeof(POINT) );
		if(*LinkCode==NULL)*LinkCode = (BYTE*)malloc(bitmap.bmWidth * bitmap.bmHeight * sizeof(BYTE));
		memset( *LinkCode,0,bitmap.bmWidth * bitmap.bmHeight * sizeof(BYTE));

		(*EdgePoint)[0].x = x0 = x = point[i].x;
		(*EdgePoint)[0].y = y0 = y = point[i].y;
		off = y*bitmap.bmWidth + x;
		*(p+off) = 56;
		val = *(q+off);
		int dt=0; int count=1;
		do{
			for(int d=dt;d<dt+8;d++){
				u=x+dx[d%8];v=y+dy[d%8];
				if(0<=u && u<bitmap.bmWidth && 0<=v && v<bitmap.bmHeight){
					if(*(q+v*bitmap.bmWidth+u)==val){
						x=u; y=v; dt=(d+5)%8;
						off = y*bitmap.bmWidth + x;
						*(p+off) = 58; 
						(*EdgePoint)[count].x=x;(*EdgePoint)[count].y=y;(*LinkCode)[count-1]=d%8;
						count++;
						break;
					}
				}
			}
		}while( !((x==x0) && (y==y0)) );

		(*LinkCode)[count-1]=0xFF;
		*EdgePointCount = count;
	}
	memcpy(*Image, map, bitmap.bmWidth*bitmap.bmHeight*sizeof(BYTE));
	free(map);
	ImageToBitmap( bitmap, *Image );
}

VOID GetHistogram(BITMAP bitmap,int *histogram, int histogramSize,int *avHistogram, int *maxHistogram){
	BYTE *p;
	int sum=0,max=0;
	if(histogram==NULL){
		histogram = (int*)malloc(histogramSize*sizeof(int));
	}
	memset(histogram,0,histogramSize*sizeof(int));
	for(int y=0;y<bitmap.bmHeight;y++){
		p=bitmap.bmBits + y*bitmap.bmWidthBytes;
		for(int x=0;x<bitmap.bmWidth;x++){
			sum+=*p;
			histogram[*p]++;
		}
	}
	*avHistogram = sum/(bitmap.bmHeight*bitmap.bmWidth);
	for(int i=0;i<histogramSize;i++){
		if(max<histogram[i])max=histogram[i];
	}
	*maxHistogram = max;
}

VOID GreyBmp(BITMAP bmp){
	BYTE *p, Gray;
	p=bmp.bmBits;
	for(int y=0;y<bmp.bmHeight;y++){
		p=bmp.bmBits + bmp.bmWidthBytes*y;
		for(int x=0;x<bmp.bmWidth;x++,p+=4){
			Gray = (p[2]*19595 + p[1]*38469 + p[0]*7472) >> 16;
			p[0] = p[1] = p[2] = (BYTE)Gray;
		}
	}
}

VOID ImageToBitmap(BITMAP bitmap, BYTE *Image){
	BYTE *q = Image;
	BYTE *p;
	int vq;
	BYTE color[12][3]={	{0xFF,0xFF,0xFF},
						{0x80,0xFF,0x00}, {0xFF,0x00,0x00}, {0xFF,0x00,0x80},
						{0x00,0x00,0xFF}, {0x00,0xFF,0x00}, {0x00,0xFF,0xFF},
						{0x00,0xFF,0x80}, {0x00,0x80,0xFF}, {0x00,0x80,0x80},
						{0x00,0x00,0x00}, {0xC0,0xC0,0xC0}  };
	for(int y=0;y<bitmap.bmHeight;y++){
		p = bitmap.bmBits + bitmap.bmWidthBytes * y;
		for(int x=0; x<bitmap.bmWidth; x++,p+=4,q++){
			if(*q){
				vq=((int)(*q)%11)+1;
				*p     = color[vq][0];
				*(p+1) = color[vq][1];
				*(p+2) = color[vq][2];
			}
		}
	}
}

VOID ShowDataByte(HWND hwnd, BYTE *DataBuf,int page,int xPos,int yPos){
	if(DataBuf==NULL)return;	
	HDC hdc = GetDC(hwnd);
	char buf[100];
	BYTE *p = DataBuf + page*512;
	Rectangle(hdc,xPos-2,yPos-2,xPos+328,yPos+328);

	HFONT hFont = CreateFont(-8,-4,0,0,0,0,0,0,0,0,0,0,0,0);
	HFONT hOldFont = SelectObject(hdc,hFont);	

	for(int i=0;i<512;i++){
		sprintf(buf,"%02X",p[i]);
		TextOut(hdc,xPos+i%16*14+i%16/8*5,yPos+i/16*10+i/256*5,buf,strlen(buf));
	}
	buf[1]=0;
	p=DataBuf+page*512;
	for(int l=0;l<32;l++){
		for(int i=0;i<16;i++){
			buf[0]=(0x1F<p[i] && p[i]<0x80)?p[i]:'.';
			TextOut(hdc,240+xPos+i*5+i/8*5,yPos+l*10+i/256*5,buf,1);
		}
		p+=16;
	}
	SelectObject(hdc,hOldFont);
	DeleteObject(hFont);
	ReleaseDC(hwnd,hdc);
}
VOID ShowEdgeData(HWND hwnd, POINT *EdgePoint, BYTE* LinkCode, int EdgePointCount){
	char buf[100];
	HDC hdc=GetDC(hwnd);
	//Rectangle(hdc,xPos-2,yPos-2,xPos+328,yPos+328);
	HFONT hFont = CreateFont(-8,-4,0,0,0,0,0,0,0,0,0,0,0,0);
	HFONT hOldFont = SelectObject(hdc,hFont);
	SetBkMode(hdc,OPAQUE);
	for(int i=0;i<EdgePointCount;i++){
		sprintf(buf,"(%d,%d) %d",EdgePoint[i].x,EdgePoint[i].y,LinkCode[i]);
		TextOut(hdc,0+i/80*50,i%80*10,buf,strlen(buf));
	}
	SelectObject(hdc,hOldFont);
	DeleteObject(hFont);
	ReleaseDC(hwnd,hdc);	
}

VOID ShowMarkData(HWND hwnd, POINT *point, int markCount,int xPos,int yPos){
	HDC hdc=GetDC(hwnd);
	char buf[100];
	//Rectangle(hdc,xPos-2,yPos-2,xPos+328,yPos+328);
	HFONT hFont = CreateFont(-8,-4,0,0,0,0,0,0,0,0,0,0,0,0);
	HFONT hOldFont = SelectObject(hdc,hFont);	
	for(int i=0;i<markCount;i++){
		sprintf(buf,"%d (%d, %d)",i,point[i].x,point[i].y);
		TextOut(hdc,xPos+i/20*60,yPos+i%20*10,buf,strlen(buf));
	}
	SelectObject(hdc,hOldFont);
	DeleteObject(hFont);
	ReleaseDC(hwnd,hdc);
}
VOID ShowMarkData2(HWND hwnd, int *mark, POINT *point, int markCount, int xPos, int yPos){
	char buf[100];
	HDC hdc=GetDC(hwnd);
	//Rectangle(hdc,xPos-2,yPos-2,xPos+328,yPos+328);
	HFONT hFont = CreateFont(-8,-4,0,0,0,0,0,0,0,0,0,0,0,0);
	HFONT hOldFont = SelectObject(hdc,hFont);	
	for(int i=0; i<markCount; i++){
		sprintf(buf, "%d-%d ", i, mark[i]);
		TextOut(hdc, xPos+i/20*80, yPos+i%20*10, buf, strlen(buf));
		sprintf(buf, "(%d, %d)", point[i].x, point[i].y);
		TextOut(hdc, xPos+30+i/20*80, yPos+i%20*10, buf, strlen(buf));		
	}
	SelectObject(hdc,hOldFont);
	DeleteObject(hFont);
	ReleaseDC(hwnd,hdc);
}
//----------------------------------------------------------------------------------------------------------------------------------------
// edge.c
// gcc edge.c -oedge.exe -mwindows
// 2023-08-06 by programfanny 

#include <windows.h>
#include <stdio.h>

VOID BinaryBmp(BITMAP bitmap, BYTE **Image, BYTE threshold);
VOID BitmapToImage(BITMAP bitmap, BYTE* Image);

VOID GetDomain(BITMAP bitmap, BYTE **Image);
VOID GetDomain2(BITMAP bitmap, BYTE **Image, POINT **point,int *markCount);
VOID GetDomain3(HWND hwnd, BITMAP bitmap, BYTE **Image, int **mark,POINT **point,int *markCount);

VOID GetEdge ( BITMAP bitmap,BYTE **pImage,POINT *point,int markCount );
VOID GetEdge2( BITMAP bitmap,BYTE **pImage,POINT **edge,int *EdgePointCount, BYTE **LinkCode, POINT *point,int markCount );

VOID GetHistogram( BITMAP bitmap,int *histogram, int histogramSize,int *avHistogram, int *maxHistogram);
VOID GreyBmp( BITMAP bitmap);
VOID FindInnerEdge( BITMAP bitmap, BYTE *pImage, POINT *EdgePoint, int EdgePointCount, POINT *seed );
VOID ImageToBitmap( BITMAP bitmap,BYTE *Image);

VOID ShowDataByte(HWND hwnd, BYTE *DataBuf, int page, int xPos, int yPos);
VOID ShowEdgeData(HWND hwnd, POINT *EdgePoint,BYTE*LinkCode,int EdgePointCount);
VOID ShowMarkData(HWND hwnd, POINT *point, int markCount, int xPos, int yPos);
VOID ShowMarkData2(HWND hwnd, int *MARK, POINT *point, int markCount, int xPos, int yPos);

VOID TraceEdge(BITMAP bitmap,BYTE *Image, BYTE *map, POINT seed, int dir,POINT **EdgePoint,int *EdgePointCount, BYTE **LinkCode,int *count);

LRESULT CALLBACK WndProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);
int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, PSTR szCmdLine, int iCmdShow){
	static TCHAR szAppName[] = TEXT("HelloWin");
	HWND hwnd;
	MSG msg;
	WNDCLASS wndclass;
	wndclass.style = CS_HREDRAW | CS_VREDRAW;
	wndclass.lpfnWndProc = WndProc;
	wndclass.cbClsExtra = 0;
	wndclass.cbWndExtra = 0;
	wndclass.hInstance = hInstance;
	wndclass.hIcon = LoadIcon(NULL,IDI_APPLICATION);
	wndclass.hCursor = LoadCursor(NULL,IDC_ARROW);
	wndclass.hbrBackground = (HBRUSH)GetStockObject(WHITE_BRUSH);
	wndclass.lpszMenuName = NULL;
	wndclass.lpszClassName = szAppName;
	if(!RegisterClass(&wndclass)){
		MessageBox(NULL,TEXT("This program requires Windows NT!"), szAppName, MB_ICONERROR);
		return 0;
	}
	hwnd = CreateWindow(szAppName,TEXT("The Hello Program"),WS_OVERLAPPEDWINDOW,CW_USEDEFAULT,CW_USEDEFAULT,CW_USEDEFAULT,CW_USEDEFAULT,NULL,NULL,hInstance,NULL);
	ShowWindow(hwnd,iCmdShow);
	UpdateWindow(hwnd);
	while(GetMessage(&msg,NULL,0,0)){
		TranslateMessage(&msg);
		DispatchMessage(&msg);
	}
	return msg.wParam;
}
LRESULT CALLBACK WndProc(HWND hwnd, UINT message,WPARAM wParam,LPARAM lParam){
	HANDLE hInstance;
	HDC hdc,hdcMem;
	PAINTSTRUCT ps;
	RECT rect;
	HFONT hFont;
	char buf[100];
	// static LPCSTR filename = "shapes.bmp";
	 static LPCSTR filename = "gear.bmp";
	// static LPCSTR filename = "rooster.bmp";
	// static LPCSTR filename = "rice02.bmp";
	// static LPCSTR filename = "gears.bmp";	 

	static HBITMAP hBitmap;

	static BITMAP bitmap;
	static BYTE *pMap, *pOrigin, *pImage ;
	// black = 0  white = 1 in Image Data
	// background = 0  foreground = 1
	
	static int *histogram,histogramSize=256,avHistogram,maxHistogram;
	
	static POINT *DomainPoints;
	static int DomainsCount;
	static int markCount, *mark;
	static POINT *point;

	static POINT *EdgePoint;
	static int EdgePointCount=0;
	static BYTE *LinkCode;

	static DWORD curPage=0,maxPage;
	static int path=0;

	int x,y;
	POINT pt;

	switch(message){
		case WM_CREATE:
			//hInstance = GetWindowsLong(hwnd,GWL_HINSTANCE);
			hInstance = ((LPCREATESTRUCT) lParam)->hInstance;
			//hBitmap = LoadBitmap(hInstance, MSKEINTRESOURCE(IDC_BITMAP));
			hBitmap = LoadImage(hInstance,filename,IMAGE_BITMAP,0,0,LR_LOADFROMFILE);
			GetObject(hBitmap,sizeof(BITMAP),&bitmap);
			bitmap.bmBits=(BYTE*)malloc(bitmap.bmWidthBytes*bitmap.bmHeight);
			GetBitmapBits(hBitmap,bitmap.bmWidthBytes*bitmap.bmHeight,bitmap.bmBits);
			pOrigin = (BYTE*)malloc(bitmap.bmWidthBytes*bitmap.bmHeight);
			GetBitmapBits(hBitmap,bitmap.bmWidthBytes*bitmap.bmHeight,pOrigin);
			maxPage = (bitmap.bmWidth*bitmap.bmHeight+511)/512;
			curPage=0;
			return 0;
		case WM_PAINT:
			hdc = BeginPaint(hwnd, &ps);
			hdcMem = CreateCompatibleDC(hdc);
			SelectObject(hdcMem,hBitmap);
			BitBlt(hdc,0,0,bitmap.bmWidth,bitmap.bmHeight,hdcMem,0,0,SRCCOPY);
			DeleteDC(hdcMem);
			//sprintf(buf,"%d",markCount);
			//TextOut(hdc,300,300,buf,strlen(buf));

			 ShowDataByte( hwnd, pImage, curPage, bitmap.bmWidth+20, 10);

			// switch(path){
			// 	case 1:
			// 		ShowMarkData( hwnd, point, markCount, bitmap.bmWidth+20, 350);
			// 		break;
			// 	case 2:
			// 		ShowMarkData2( hwnd, mark, point, markCount, bitmap.bmWidth+20, 350);
			// 		break;
			// }
			// if(EdgePointCount){
			// 	POINT seed;
			 	//VOID FindInnerEdge( BITMAP bitmap, BYTE *pImage, POINT *EdgePoint, int EdgePointCount, POINT *seed );
			// 	FindInnerEdge(bitmap,pImage,EdgePoint,EdgePointCount,&seed);
			//	sprintf(buf,"seed ( %d %d )",seed.x,seed.y);
			// 	TextOut(hdc,500,300,buf,strlen(buf));
/*
			 	int m=0,n=EdgePointCount/2;
			 	int mx=	EdgePoint[0].x,my=EdgePoint[0].y;
			 	int nx=EdgePoint[EdgePointCount/2].x,ny=EdgePoint[EdgePointCount/2].y;
			 	int tx=mx-nx,ty=my-ny;
			 	if(tx<0)tx=-tx;if(ty<0)ty=-ty;
			 	int td=(tx>ty)?tx:ty;
			 	int x,y;
			 	BYTE *p=pImage;

			 	for(int t=0;t<td;t++){
			 		x=mx+t*tx/td; y=my+t*ty/td;
			 		if(*(p+y*bitmap.bmWidth+x)){
			 			SetPixel(hdc,x,y,RGB(255,0,0));
			 		}else{
			 			x=mx+(t-1)*tx/td; y=my+(t-1)*ty/td;
						seed.x=x;seed.y=y;break;
				 	}
				}
			 	sprintf(buf,"seed ( %d %d )",seed.x,seed.y);
			 	TextOut(hdc,500,300,buf,strlen(buf));
*/
			//}

			//if(EdgePointCount){
			//	ShowEdgeData(hwnd,EdgePoint,LinkCode,EdgePointCount);
			//}

			EndPaint(hwnd,&ps);
			return 0;
		case WM_KEYDOWN:
			switch(wParam){
				case VK_ESCAPE:
					PostMessage(hwnd,WM_DESTROY,0,0);
					break;
				case VK_F1:
					strcpy(buf,"F1 - Show this Message\n");
					strcat(buf,"F2 - Orginal Image\n");
					strcat(buf,"F3 - Grey the Image\n");
					strcat(buf,"F4 - Binary the Image\n");
					strcat(buf,"F5 - Get the Domain From Image\n");
					strcat(buf,"F6 - Get the Edge by corrosion\n");
					strcat(buf,"F7 - Trace the Edge & LinkCode\n");
					strcat(buf,"F8 - \n");
					MessageBox(NULL,buf,"Help",MB_OK);
					break;	
				case VK_F2:
					memcpy(bitmap.bmBits,pOrigin,bitmap.bmWidthBytes*bitmap.bmHeight);
					break;
				case VK_F3:
					memcpy(bitmap.bmBits,pOrigin,bitmap.bmWidthBytes*bitmap.bmHeight);
					GreyBmp(bitmap);
					break;
				case VK_F4:
					memcpy(bitmap.bmBits,pOrigin,bitmap.bmWidthBytes*bitmap.bmHeight);
					GreyBmp(bitmap);
					GetHistogram(bitmap,histogram,histogramSize,&avHistogram,&maxHistogram);
					BinaryBmp(bitmap,&pImage,(BYTE)(avHistogram*2/3));
					break;
				case VK_F5:
					memcpy(bitmap.bmBits,pOrigin,bitmap.bmWidthBytes*bitmap.bmHeight);
					GreyBmp( bitmap );
					GetHistogram( bitmap, histogram, histogramSize, &avHistogram, &maxHistogram);
					BinaryBmp( bitmap,&pImage, (BYTE)(avHistogram*2/3));
					GetDomain( bitmap, &pImage );
					path=0;
					break;
				case VK_F6:
					memcpy(bitmap.bmBits,pOrigin,bitmap.bmWidthBytes*bitmap.bmHeight);
					GreyBmp( bitmap );
					GetHistogram( bitmap, histogram, histogramSize, &avHistogram, &maxHistogram);
					BinaryBmp( bitmap,&pImage, (BYTE)(avHistogram*5/5));
					GetDomain2( bitmap, &pImage, &point, &markCount );
					path=1;
					break;
				case VK_F7:
					memcpy( bitmap.bmBits,pOrigin,bitmap.bmWidthBytes*bitmap.bmHeight );
					GreyBmp( bitmap );
					GetHistogram( bitmap, histogram, histogramSize, &avHistogram, &maxHistogram );
					BinaryBmp( bitmap,&pImage, (BYTE)(avHistogram*2/3) );
					GetDomain3( hwnd, bitmap, &pImage, &mark,&point, &markCount );
					path=2;
					GetEdge( bitmap, &pImage, point, markCount );
					break;
				case VK_F8:					
					memcpy( bitmap.bmBits,pOrigin,bitmap.bmWidthBytes*bitmap.bmHeight );
					GreyBmp( bitmap );
					GetHistogram( bitmap, histogram, histogramSize, &avHistogram, &maxHistogram );
					BinaryBmp( bitmap, &pImage,(BYTE)(avHistogram*2/3) );
					GetDomain3( hwnd, bitmap, &pImage, &mark,&point, &markCount );
					path=2;
					GetEdge2( bitmap, &pImage, &EdgePoint,&EdgePointCount, &LinkCode, point, markCount );
					//FindInnerEdge(bitmap, pImage, EdgePoint, EdgePointCount,point,markCount);
					break;
				case VK_F9:
					MessageBox(NULL,"You pressed F9","Press",MB_OK);
					break;
				case VK_PRIOR:
					curPage--;
					if(curPage==0xFFFFFFFF)curPage=maxPage-1;
					break;
				case VK_NEXT:
					curPage++;
					if(curPage==maxPage)curPage=0;
					break;

			}
			SetBitmapBits(hBitmap,bitmap.bmWidthBytes*bitmap.bmHeight,bitmap.bmBits);
			InvalidateRect(hwnd,NULL,TRUE);
			return 0;
		case WM_RBUTTONDOWN:
			x=LOWORD(lParam);y=HIWORD(lParam);
			hdc = GetDC(hwnd);
			StretchBlt(hdc,0,400,110,110,hdc,x-5,y-5,11,11,SRCCOPY);
			ReleaseDC(hwnd,hdc);
			return 0;		
		case WM_DESTROY:
			if(point)free(point);
			if(EdgePoint)free(EdgePoint);
			if(LinkCode)free(LinkCode);
			if(pImage)free(pImage);
			if(pMap)free(pMap);
			if(bitmap.bmBits)free(bitmap.bmBits);
			if(pOrigin)free(pOrigin);
			PostQuitMessage(0);
			return 0;
	}
	return DefWindowProc(hwnd, message,wParam,lParam);
}

VOID BinaryBmp(BITMAP bitmap, BYTE **Image, BYTE threshold){
	BYTE *p;
	// Filter()
	//BYTE *q;
	//BYTE *Image=(BYTE*)malloc(bitmap.bmWidth*bitmap.bmHeight*sizeof(BYTE));

	for(int y=0;y<bitmap.bmHeight;y++){
		p=bitmap.bmBits + y*bitmap.bmWidthBytes;
		for(int x=0;x<bitmap.bmWidth;x++,p+=4){			
			if(*p>threshold){
				p[0] = p[1]= p[2]=0xFF;
			}else{
				p[0] = p[1]= p[2]=0x00;
			}
		}
	}
}
VOID BitmapToImage(BITMAP bitmap, BYTE* image){
	BYTE *p,*q;
	q=image;p=bitmap.bmBits;
	if(*p==0xFF){
		for(int y=0;y<bitmap.bmHeight;y++){		
			for(int x=0;x<bitmap.bmWidth;x++,q++){
				*q = (0xFF-*(p+4*x))/0xFF; // Inverse case // white -> 0 display : black , background  black->1 display : white , foreColor
			}
			p += bitmap.bmWidthBytes;
		}
	}else{
		for(int y=0;y<bitmap.bmHeight;y++){		
			for(int x=0;x<bitmap.bmWidth;x++,q++){
				*q=*(p+4*x)/0xFF;     //  Normal case       // black -> 0 display : black , background  white->1 display : white , foreColor
			}
			p += bitmap.bmWidthBytes;
		}		
	}
}
VOID GetDomain ( BITMAP bitmap, BYTE **Image ){
	typedef struct tag_domain{
		POINT pt;
		struct tag_domain *next;
	}DOMAIN;	
	// 区域填充
	BYTE *map;
	BYTE *p,*s;
	int width = bitmap.bmWidth,height=bitmap.bmHeight;
	
	int domainSize;
	int x, y, d, u, v;
	int dx[8] = { -1, -1,  0,  1,  1,  1,  0, -1 };
	int dy[8] = {  0, -1, -1, -1,  0,  1,  1,  1 };
	
	int label, cnt, min,max,dt;
	DOMAIN *DomainList = NULL, *pDomain,*qDomain;

	if(*Image == NULL)*Image = (BYTE*)malloc(width*height*sizeof(BYTE));

	BitmapToImage(bitmap,*Image);

	int *mark=(int*)malloc(width*height*sizeof(int));

	p= *Image; label = 0;
	qDomain = DomainList;

	for(int y = 0; y < height; y++){
		for(int x = 0; x < width; x++, p++){
			if(*p==0)continue;
			cnt=0; min=1000;
			for(d=0; d<4; d++){
				u=x+dx[d],v=y+dy[d];
				if( 0 <= u && u < width && 0 <= v && v < height ){
					s = *Image + v * width + u;
					cnt += *s;
					if(*s>0 && min>*s){
						min=*s;
					}
				}
			}
			
			if(cnt==0){
				pDomain = (DOMAIN*)malloc(sizeof(DOMAIN));
				pDomain->next = qDomain;
				pDomain->pt.x = x, pDomain->pt.y = y;
				qDomain = pDomain;

				label++;
				*p = label;
				mark[label] = label;

			}else{
				*p=min;				
				for(d=0;d<4;d++){
					u=x+dx[d],v=y+dy[d];
					if(0<=u && u<width && 0<=v && v<height){
						s = *Image + v * width + u;
						if(*s && mark[*s] > min)
							mark[*s] = min;
					}
				}
			}
		}
	}
	domainSize = label+1;
	for(int i=0;i<domainSize;i++){
		int j=i;
		while(mark[j]!=j){
			mark[j]=mark[mark[j]];
			j--;
		}
	}
	p = *Image;
	for(int y=0;y<height;y++){
		for(int x=0;x<width;x++,p++){
			*p=mark[*p];
		}
	}

	ImageToBitmap( bitmap, *Image );

	free(mark);
}
// Get Domain count and return a seed point for each domain. Fill the domain in different colors 
VOID GetDomain2 ( BITMAP bitmap, BYTE **Image, POINT** point, int *markCount){
	// 区域填充
	BYTE *map;
	BYTE *p,*q;
	int width = bitmap.bmWidth,height=bitmap.bmHeight;
	
	int domainSize;
	int x, y, d, u, v;
	int dx[8] = { -1, -1,  0,  1,  1,  1,  0, -1 };
	int dy[8] = {  0, -1, -1, -1,  0,  1,  1,  1 };
	int of[8] = { -1, -width-1, -width, -width+1, 1, width+1, width, width-1 };
	BYTE *r, *s, *t;
	int label, cnt, min,max,dt;

	if(*Image == NULL)*Image = (BYTE*)malloc(width*height*sizeof(BYTE));

	BitmapToImage(bitmap,*Image);

	int *mark=(int*)malloc(width*height*sizeof(int));
	*point = (POINT*)malloc(width*height*sizeof(POINT));
	memset(mark,0,width*height*sizeof(int));
	memset(*point,0,width*height*sizeof(POINT));

	p= *Image; label = 0;

	for(int y = 0; y < height; y++){
		for(int x = 0; x < width; x++, p++){
			if(*p==0) continue;
			cnt=0; min=1000;
			for(d=0; d<4; d++){
				u=x+dx[d],v=y+dy[d];
				if( 0 <= u && u < width && 0 <= v && v < height ){
					s = *Image + v * width + u;
					cnt += *s;
					if(*s>0 && min>*s){
						min=*s;
					}
				}
			}
			
			if(cnt==0){
				label++;
				*p = label;
				mark[label] = label;
				(*point)[label].x=x;
				(*point)[label].y=y;
				
			}else{
				*p=min;				
				for(d=0;d<4;d++){
					u=x+dx[d],v=y+dy[d];
					if(0<=u && u<width && 0<=v && v<height){
						s = *Image + v * width + u;
						if(*s && mark[*s] > min)
							mark[*s] = min;
					}
				}
			}
		}
	}

	// Combine the Connect mark 
	*markCount = domainSize = label+1;
		
	for(int i=0;i<domainSize;i++){
		int j=i;
		while(mark[j]!=j){
			mark[j]=mark[mark[j]];
			j--;
		}
	}

	// fill the image with the mark

	p = *Image;
	for(int y=0;y<height;y++){
		for(int x=0;x<width;x++,p++){
			*p=mark[*p];
		}
	}

	// Pack the  mark list and seed point
	int l=0;
	for(int i=0;i<*markCount;i++){
		if(mark[i]==i){
		mark[l]=l;	
		(*point)[l].x = (*point)[i].x;
		(*point)[l].y = (*point)[i].y;
		l++;
		}
	}

	*markCount = l;
	free(mark);

	ImageToBitmap( bitmap, *Image );
}
VOID GetDomain3 (HWND hwnd, BITMAP bitmap, BYTE **Image, int **mark, POINT** point,int *markCount){
	// 区域填充
	BYTE *map;
	BYTE *p,*q;
	int width = bitmap.bmWidth,height=bitmap.bmHeight;
	
	int domainSize;
	int x, y, d, u, v;
	int dx[8] = { -1, -1,  0,  1,  1,  1,  0, -1 };
	int dy[8] = {  0, -1, -1, -1,  0,  1,  1,  1 };
	int of[8] = { -1, -width-1, -width, -width+1, 1, width+1, width, width-1 };
	BYTE *r, *s, *t;
	int label, cnt, min,max,dt;

	if(*Image == NULL)*Image = (BYTE*)malloc(width*height*sizeof(BYTE));

	BitmapToImage(bitmap,*Image);

	if(*mark==NULL){
		*mark=(int*)malloc(width*height*sizeof(int));
		*point = (POINT*)malloc(width*height*sizeof(POINT));
	}
	memset(*mark,0,width*height*sizeof(int));
	memset(*point,0,width*height*sizeof(POINT));

	p= *Image; label = 0;

	for(int y = 0; y < height; y++){
		for(int x = 0; x < width; x++, p++){
			if(*p==0) continue;
			cnt=0; min=1000;
			for(d=0; d<4; d++){
				u=x+dx[d],v=y+dy[d];
				if( 0 <= u && u < width && 0 <= v && v < height ){
					s = *Image + v * width + u;
					cnt += *s;
					if(*s>0 && min>*s){
						min=*s;
					}
				}
			}
			
			if(cnt==0){
				label++;
				*p = label;
				(*mark)[label] = label;
				(*point)[label].x=x;
				(*point)[label].y=y;
				
			}else{
				*p=min;				
				for(d=0;d<4;d++){
					u=x+dx[d],v=y+dy[d];
					if(0<=u && u<width && 0<=v && v<height){
						s = *Image + v * width + u;
						if(*s && (*mark)[*s] > min)
							(*mark)[*s] = min;
					}
				}
			}
		}
	}

	// Combine the Connect mark 
	*markCount = domainSize = label+1;
		
	for(int i=0;i<domainSize;i++){
		int j=i;
		while((*mark)[j]!=j){
			(*mark)[j]=(*mark)[(*mark)[j]];
			j--;
		}
	}

	// fill the image with the mark

	p = *Image;
	for(int y=0;y<height;y++){
		for(int x=0;x<width;x++,p++){
			*p=(*mark)[*p];
		}
	}
	// Pack the  mark list and seed point
	int l=0;
	for(int i=0;i<*markCount;i++){
		if((*mark)[i]==i){
		(*mark)[l]=l;	
		(*point)[l].x = (*point)[i].x;
		(*point)[l].y = (*point)[i].y;
		l++;
		}
	}

	*markCount = l;

	ImageToBitmap( bitmap, *Image );
}
VOID GetEdge( BITMAP bitmap, BYTE **Image, POINT *point, int markCount ){
	BYTE *map,*p,*q,*s;
	int u,v;
	int dx[8]={ -1, -1,  0,  1,  1,  1,  0, -1 };
	int dy[8]={  0, -1, -1, -1,  0,  1,  1,  1 };

	if(*Image==NULL){
		*Image = (BYTE*)malloc( bitmap.bmWidth * bitmap.bmHeight * sizeof(BYTE) );
	}
	// BitmapToImage(bitmap,*Image);

	map = (BYTE*)malloc( bitmap.bmWidth * bitmap.bmHeight * sizeof(BYTE) );
	//memset( map, 0, bitmap.bmWidth * bitmap.bmHeight * sizeof(BYTE) );
	memcpy(map,*Image,bitmap.bmWidth * bitmap.bmHeight * sizeof(BYTE) );
	p=map; q=*Image;
	for(int y=0;y<bitmap.bmHeight;y++){
		for(int x=0;x<bitmap.bmWidth;x++,p++,q++){
			// 统计每个点周围像素点个数，
			// 若周围有8个像素点，则是内部点，像素值不变，
			// 若为0个，则为孤立点，抹去该点，像素值变为相邻点的像素值
			// 若为其他值，则是边界点，
			if(*q){
				int count=0;
				for(int d=0;d<8;d++){
					u=x+dx[d];v=y+dy[d];
					if(0<=u && u<bitmap.bmWidth && 0<=v && v<bitmap.bmHeight){
						s=*Image+v*bitmap.bmWidth+u;
						count += (*s>0);
					}
				}
				switch(count){
					case 0:
						*p=*s;
					break;
					case 8:
						*p=10;
					break;
					default:
						*p=*p+2;
						if(*p==0){*p=1;}
					break;
				}
			}
		}
	}

	memcpy(*Image, map, bitmap.bmWidth*bitmap.bmHeight*sizeof(BYTE));
	free(map);
	ImageToBitmap( bitmap, *Image );
}
// Trance the edge and get the link code for each domain from the point.
VOID GetEdge2( BITMAP bitmap,BYTE **Image, POINT **EdgePoint,int *EdgePointCount, BYTE **LinkCode, POINT *point, int markCount ){

	BYTE *map,*p,*q,*s,val;
	int x0,y0,x,y,u,v,off;
	int dx[8]={ -1, -1,  0,  1,  1,  1,  0, -1 };
	int dy[8]={  0, -1, -1, -1,  0,  1,  1,  1 };
	POINT seed;
	int count,dt;

	if(*Image==NULL){
		*Image = (BYTE*)malloc( bitmap.bmWidth * bitmap.bmHeight * sizeof(BYTE) );
		BitmapToImage(bitmap,*Image);	
	}

	map = (BYTE*)malloc( bitmap.bmWidth * bitmap.bmHeight * sizeof(BYTE) );
	
	memset( map, 10, bitmap.bmWidth * bitmap.bmHeight * sizeof(BYTE) );

	p=map; q=*Image;

	for(int i=markCount-1;i>0;i--){

		if(*EdgePoint==NULL)*EdgePoint = (POINT*)malloc(bitmap.bmWidth * bitmap.bmHeight * sizeof(POINT));
		memset( *EdgePoint, 0, bitmap.bmWidth * bitmap.bmHeight * sizeof(POINT) );
		if(*LinkCode==NULL)*LinkCode = (BYTE*)malloc(bitmap.bmWidth * bitmap.bmHeight * sizeof(BYTE));
		memset( *LinkCode,0,bitmap.bmWidth * bitmap.bmHeight * sizeof(BYTE));
		//Trace edge
		//VOID TraceEdge(BITMAP bitmap,BYTE *Image,POINT seed,POINT **EdgePoint,int *EdgePointCount, BYTE **LinkCode);
		//TraceEdge(bitmap,*Image,point[i],EdgePoint,EdgePointCount,LinkCode);
		seed.x=	point[i].x;	seed.y = point[i].y;
		count=0;
		TraceEdge(bitmap,*Image, map,seed,0,EdgePoint,EdgePointCount,LinkCode,&count);

			// (*EdgePoint)[count].x=x0=x=seed.x;(*EdgePoint)[count].y=y0=y=seed.y;
			// off = y*bitmap.bmWidth + x;
			// *(p+off) = 0x38;
			// val = *(q+off);
			// dt=0; count++;
			// do{
			// 	for(int d=dt;d<dt+8;d++){
			// 		u=x+dx[d%8];v=y+dy[d%8];
			// 		if(0<=u && u<bitmap.bmWidth && 0<=v && v<bitmap.bmHeight){
			// 			if(*(q+v*bitmap.bmWidth+u)==val){
			// 				x=u; y=v; dt=(d+5)%8;
			// 				off = y*bitmap.bmWidth + x;
			// 				*(p+off) = 0x38; 
			// 				(*EdgePoint)[count].x=x;(*EdgePoint)[count].y=y;(*LinkCode)[count-1]=d%8;
			// 				count++;
			// 				break;
			// 			}
			// 		}
			// 	}
			// }while( !((x==x0) && (y==y0)) );
			// (*LinkCode)[count-1]=0xFF;
			// *EdgePointCount = count;

		FindInnerEdge(bitmap,*Image,*EdgePoint,*EdgePointCount,&seed);	
		count++;
		TraceEdge(bitmap,*Image, map,seed,5,EdgePoint,EdgePointCount,LinkCode,&count);

			// (*EdgePoint)[count].x=x0=x=seed.x;(*EdgePoint)[count].y=y0=y=seed.y;
			// off = y*bitmap.bmWidth + x;
			// *(p+off) = 0x38;
			// val = *(q+off);
			// dt=5; count++;
			// do{
			// 	for(int d=dt;d<dt+8;d++){
			// 		u=x+dx[d%8];v=y+dy[d%8];
			// 		if(0<=u && u<bitmap.bmWidth && 0<=v && v<bitmap.bmHeight){
			// 			if(*(q+v*bitmap.bmWidth+u)==val){
			// 				x=u; y=v; dt=(d+5)%8;
			// 				off = y*bitmap.bmWidth + x;
			// 				*(p+off) = 0x38; 
			// 				(*EdgePoint)[count].x=x;(*EdgePoint)[count].y=y;(*LinkCode)[count-1]=d%8;
			// 				count++;
			// 				break;
			// 			}
			// 		}
			// 	}
			// }while( !((x==x0) && (y==y0)) );
 			// (*LinkCode)[count-1]=0xFF;
			// *EdgePointCount = count;
	
	}
	//memcpy(*Image, map, bitmap.bmWidth*bitmap.bmHeight*sizeof(BYTE));

	ImageToBitmap( bitmap, map );
	free(map);
}
VOID GetHistogram(BITMAP bitmap,int *histogram, int histogramSize,int *avHistogram, int *maxHistogram){
	BYTE *p;
	int sum=0,max=0;
	if(histogram==NULL){
		histogram = (int*)malloc(histogramSize*sizeof(int));
	}
	memset(histogram,0,histogramSize*sizeof(int));
	for(int y=0;y<bitmap.bmHeight;y++){
		p=bitmap.bmBits + y*bitmap.bmWidthBytes;
		for(int x=0;x<bitmap.bmWidth;x++){
			sum+=*p;
			histogram[*p]++;
		}
	}
	*avHistogram = sum/(bitmap.bmHeight*bitmap.bmWidth);
	for(int i=0;i<histogramSize;i++){
		if(max<histogram[i])max=histogram[i];
	}
	*maxHistogram = max;
}
VOID GreyBmp(BITMAP bmp){
	BYTE *p, Gray;
	p=bmp.bmBits;
	for(int y=0;y<bmp.bmHeight;y++){
		p=bmp.bmBits + bmp.bmWidthBytes*y;
		for(int x=0;x<bmp.bmWidth;x++,p+=4){
			Gray = (p[2]*19595 + p[1]*38469 + p[0]*7472) >> 16;
			p[0] = p[1] = p[2] = (BYTE)Gray;
		}
	}
}
VOID FindInnerEdge(BITMAP bitmap, BYTE *Image, POINT *EdgePoint, int EdgePointCount, POINT *seed){
 	int m=0,n=EdgePointCount/2;
 	int mx=	EdgePoint[0].x,my=EdgePoint[0].y;
 	int nx=EdgePoint[EdgePointCount/2].x,ny=EdgePoint[EdgePointCount/2].y;
 	int tx=mx-nx,ty=my-ny;
 	if(tx<0)tx=-tx;if(ty<0)ty=-ty;
 	int td=(tx>ty)?tx:ty;
 	int x,y;
 	BYTE *p = Image;
 	for(int t=0;t<td;t++){
 		x=mx+t*tx/td; y=my+t*ty/td;
 		if(*(p+y*bitmap.bmWidth+x)==0){
 			seed->x=mx+(t-1)*tx/td; seed->y=my+(t-1)*ty/td;
 			return;
 		}
 	}
 	seed->x=-1;seed->y=-1; 	
}
VOID ImageToBitmap(BITMAP bitmap, BYTE *Image){
	BYTE *q = Image;
	BYTE *p;
	int vq;
	BYTE color[12][3]={	{0xFF,0xFF,0xFF},
						{0x80,0xFF,0x00}, {0xFF,0x00,0x00}, {0xFF,0x00,0x80},
						{0x00,0x00,0xFF}, {0x00,0xFF,0x00}, {0x00,0xFF,0xFF},
						{0x00,0xFF,0x80}, {0x00,0x80,0xFF}, {0x00,0x80,0x80},
						{0x00,0x00,0x00}, {0xC0,0xC0,0xC0}  };
	for(int y=0;y<bitmap.bmHeight;y++){
		p = bitmap.bmBits + bitmap.bmWidthBytes * y;
		for(int x=0; x<bitmap.bmWidth; x++,p+=4,q++){
			if(*q){
				vq=((int)(*q)%11)+1;
				*p     = color[vq][0];
				*(p+1) = color[vq][1];
				*(p+2) = color[vq][2];
			}
		}
	}
}
VOID ShowDataByte(HWND hwnd, BYTE *DataBuf,int page,int xPos,int yPos){
	if(DataBuf==NULL)return;	
	HDC hdc = GetDC(hwnd);
	char buf[100];
	BYTE *p = DataBuf + page*512;
	Rectangle(hdc,xPos-2,yPos-2,xPos+328,yPos+328);

	HFONT hFont = CreateFont(-8,-4,0,0,0,0,0,0,0,0,0,0,0,0);
	HFONT hOldFont = SelectObject(hdc,hFont);	

	for(int i=0;i<512;i++){
		sprintf(buf,"%02X",p[i]);
		TextOut(hdc,xPos+i%16*14+i%16/8*5,yPos+i/16*10+i/256*5,buf,strlen(buf));
	}
	buf[1]=0;
	p=DataBuf+page*512;
	for(int l=0;l<32;l++){
		for(int i=0;i<16;i++){
			buf[0]=(0x1F<p[i] && p[i]<0x80)?p[i]:'.';
			TextOut(hdc,240+xPos+i*5+i/8*5,yPos+l*10+i/256*5,buf,1);
		}
		p+=16;
	}
	SelectObject(hdc,hOldFont);
	DeleteObject(hFont);
	ReleaseDC(hwnd,hdc);
}
VOID ShowEdgeData(HWND hwnd, POINT *EdgePoint, BYTE* LinkCode, int EdgePointCount){
	char buf[100];
	HDC hdc=GetDC(hwnd);
	//Rectangle(hdc,xPos-2,yPos-2,xPos+328,yPos+328);
	HFONT hFont = CreateFont(-8,-4,0,0,0,0,0,0,0,0,0,0,0,0);
	HFONT hOldFont = SelectObject(hdc,hFont);
	SetBkMode(hdc,OPAQUE);
	for(int i=0;i<EdgePointCount;i++){
		sprintf(buf,"(%d,%d) %d",EdgePoint[i].x,EdgePoint[i].y,LinkCode[i]);
		TextOut(hdc,0+i/80*50,i%80*10,buf,strlen(buf));
	}
	SelectObject(hdc,hOldFont);
	DeleteObject(hFont);
	ReleaseDC(hwnd,hdc);	
}
VOID ShowMarkData(HWND hwnd, POINT *point, int markCount,int xPos,int yPos){
	HDC hdc=GetDC(hwnd);
	char buf[100];
	//Rectangle(hdc,xPos-2,yPos-2,xPos+328,yPos+328);
	HFONT hFont = CreateFont(-8,-4,0,0,0,0,0,0,0,0,0,0,0,0);
	HFONT hOldFont = SelectObject(hdc,hFont);	
	for(int i=0;i<markCount;i++){
		sprintf(buf,"%d (%d, %d)",i,point[i].x,point[i].y);
		TextOut(hdc,xPos+i/20*60,yPos+i%20*10,buf,strlen(buf));
	}
	SelectObject(hdc,hOldFont);
	DeleteObject(hFont);
	ReleaseDC(hwnd,hdc);
}
VOID ShowMarkData2(HWND hwnd, int *mark, POINT *point, int markCount, int xPos, int yPos){
	char buf[100];
	HDC hdc=GetDC(hwnd);
	//Rectangle(hdc,xPos-2,yPos-2,xPos+328,yPos+328);
	HFONT hFont = CreateFont(-8,-4,0,0,0,0,0,0,0,0,0,0,0,0);
	HFONT hOldFont = SelectObject(hdc,hFont);	
	for(int i=0; i<markCount; i++){
		sprintf(buf, "%d-%d ", i, mark[i]);
		TextOut(hdc, xPos+i/20*80, yPos+i%20*10, buf, strlen(buf));
		sprintf(buf, "(%d, %d)", point[i].x, point[i].y);
		TextOut(hdc, xPos+30+i/20*80, yPos+i%20*10, buf, strlen(buf));		
	}
	SelectObject(hdc,hOldFont);
	DeleteObject(hFont);
	ReleaseDC(hwnd,hdc);
}
VOID TraceEdge(BITMAP bitmap,BYTE *Image, BYTE *map, POINT seed, int dir, POINT **EdgePoint,int *EdgePointCount, BYTE **LinkCode,int *count){
	BYTE *p,*q,*s,val;
	int x0,y0,x,y,u,v,off,dt,Count;
	int dx[8]={ -1, -1,  0,  1,  1,  1,  0, -1 };
	int dy[8]={  0, -1, -1, -1,  0,  1,  1,  1 };

	if(*EdgePoint==NULL)*EdgePoint = (POINT*)malloc(bitmap.bmWidth * bitmap.bmHeight * sizeof(POINT));
	memset( *EdgePoint, 0, bitmap.bmWidth * bitmap.bmHeight * sizeof(POINT) );
	if(*LinkCode==NULL)*LinkCode = (BYTE*)malloc(bitmap.bmWidth * bitmap.bmHeight * sizeof(BYTE));
	memset( *LinkCode,0,bitmap.bmWidth * bitmap.bmHeight * sizeof(BYTE));

	p=map; q=Image;
	Count=*count;
	dt=dir;
	(*EdgePoint)[Count].x = x0 = x = seed.x;
	(*EdgePoint)[Count].y = y0 = y = seed.y;
	off = y*bitmap.bmWidth + x;
	*(p+off) = 0x38;
	val = *(q+off);
	Count++;
	do{
		for(int d=dt;d<dt+8;d++){
			u=x+dx[d%8];v=y+dy[d%8];
			if(0<=u && u<bitmap.bmWidth && 0<=v && v<bitmap.bmHeight){
				if(*(q+v*bitmap.bmWidth+u)==val){
					x=u; y=v; dt=(d+5)%8;
					off = y*bitmap.bmWidth + x;
					*(p+off) = 0x38; 
					(*EdgePoint)[Count].x=x;(*EdgePoint)[Count].y=y;(*LinkCode)[Count-1]=d%8;
					Count++;
					break;
				}
			}
		}
	}while( !((x==x0) && (y==y0)) );
	(*LinkCode)[Count-1]=0xFF;
	*EdgePointCount = Count;
}
/*
	-------------------------------------------------------
	To get hInstance: 
	 01	hInstance = GetWindowsLong(hwnd,GWL_HINSTANCE);
	 02	hInstance = ((LPCREATESTRUCT) lParam)->hInstance;
	 03 globe variable hInstance
	-------------------------------------------------------
	// Formulas:
	// Gray = 0.299 R' + 0.587 G' + 0.114 B' 
	//      0.299 * 65536 = 19595.264 ≈ 19595
	        0.587 * 65536 + (0.264) = 38469.632 + 0.264 = 38469.896 ≈ 38469
	        0.114 * 65536 + (0.896) =  7471.104 + 0.896 = 7472
	Gray = (R*1 + G*2 + B*1) >> 2
	Gray = (R*2 + G*5 + B*1) >> 3
	Gray = (R*4 + G*10 + B*2) >> 4
	Gray = (R*9 + G*19 + B*4) >> 5
	Gray = (R*19 + G*37 + B*8) >> 6
	Gray = (R*38 + G*75 + B*15) >> 7
	Gray = (R*76 + G*150 + B*30) >> 8
	Gray = (R*153 + G*300 + B*59) >> 9
	Gray = (R*306 + G*601 + B*117) >> 10
	Gray = (R*612 + G*1202 + B*234) >> 11
	Gray = (R*1224 + G*2405 + B*467) >> 12
	Gray = (R*2449 + G*4809 + B*934) >> 13
	Gray = (R*4898 + G*9618 + B*1868) >> 14
	Gray = (R*9797 + G*19235 + B*3736) >> 15
	Gray = (R*19595 + G*38469 + B*7472) >> 16
	Gray = (R*39190 + G*76939 + B*14943) >> 17
	Gray = (R*78381 + G*153878 + B*29885) >> 18
	Gray = (R*156762 + G*307757 + B*59769) >> 19
	Gray = (R*313524 + G*615514 + B*119538) >> 20
	-----------------------------------
	// Calculate histogram
	int ptr = 0;
	while (ptr < srcData.length) {
	   int h = 0xFF & srcData[ptr];
	   histData[h] ++;
	   ptr ++;
	}

	// Total number of pixels
	int total = srcData.length;

	float sum = 0;
	for (int t=0 ; t<256 ; t++) sum += t * histData[t];

	float sumB = 0;
	int wB = 0;
	int wF = 0;

	float varMax = 0;
	threshold = 0;

	for (int t=0 ; t<256 ; t++) {
	   wB += histData[t];               // Weight Background
	   if (wB == 0) continue;

	   wF = total - wB;                 // Weight Foreground
	   if (wF == 0) break;

	   sumB += (float) (t * histData[t]);

	   float mB = sumB / wB;            // Mean Background
	   float mF = (sum - sumB) / wF;    // Mean Foreground

	   // Calculate Between Class Variance
	   float varBetween = (float)wB * (float)wF * (mB - mF) * (mB - mF);

	   // Check if new maximum found
	   if (varBetween > varMax) {
	      varMax = varBetween;
	      threshold = t;
	   }
	}
	--------------------------------------------------------------------
	if (EdgePointCount!=0){
		//	for(int i=0;i<10;i++){
		//		sprintf(buf,"edge %d ( %d , %d )",i,EdgePoint[i].x, EdgePoint[i].y );
		//		TextOut(hdc,700,i*20,buf,strlen(buf));
		//	}
		//}
		// 	sprintf(buf,"%d  %p",bitmap.bmWidth,pMap);
		// 	TextOut(hdc,100,140,buf,strlen(buf));
		//  if(pMap)ShowImage(hdc,bitmap,pMap);
		///*
		  if(markCount){
			HFONT hFont = CreateFont(-8,-4,0,0,0,0,0,0,0,0,0,0,0,0);
			// HFONT hOldFont = SelectObject(hdc,hFont);			  	
		  	int count =0;
		  	for(int i=0;i<DomainsCount;i++){
		  		sprintf(buf,"%d %d  (%d, %d) ",i,mark[i],DomainPoints[i].x,DomainPoints[i].y);
		  		TextOut(hdc,10+i/15*200,350+i%15*15,buf,strlen(buf));
		  		Ellipse(hdc,DomainPoints[i].x-2,DomainPoints[i].y-2,DomainPoints[i].x+2,DomainPoints[i].y+2);
		  		MoveToEx(hdc,DomainPoints[i].x,DomainPoints[i].y,NULL);
		  		LineTo(hdc,10+i/15*200,350+i%15*15);
		  		if(mark[i]==i){
		  			count++;
		  		}
		  	}
		 
		  	//SelectObject(hdc,hOldFont);
		  	sprintf(buf,"labelCount =  %d count = %d ",markCount,count);
		  	TextOut(hdc,0,770,buf,strlen(buf));
		  }
		 
		  
	if (EdgePointCount!=0){
		HFONT hFont = CreateFont(-10,-5,0,0,0,0,0,0,0,0,0,0,0,0);
		HFONT hOldFont = SelectObject(hdc,hFont);
		for(int i=0; i<for(int i=600; i<700; i++){
		for(int i=600; i<700; i++){
			sprintf(buf,"%d (%d , %d) %02X ",i,EdgePoint[i].x,EdgePoint[i].y,linkCode[i]);
			TextOut(hdc,800+(i-600)/30*100,(i-600)%30*14,buf,strlen(buf));
		}
		SelectObject(hdc,hOldFont);
		}
	
		//StretchBlt(hdc,300,0,bitmap.bmWidth*3,bitmap.bmHeight*3,hdc,0,0,bitmap.bmWidth,bitmap.bmHeight,SRCCOPY);
		//StretchBlt(hdc,400,000,110,110,hdc,547-5,88-5,11,11,SRCCOPY);
*/
